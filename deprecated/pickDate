
    const pickDate = (date: string) => {
      let type = "selected";
      //没有日期，直接返回
      if (!date) {
        return {
          type: "disabled",
          value: []
        };
      }
      const index = selected.indexOf(date);
      //bindData 状态下，且selected的length为0，点击不可选日期，返回
      //无效日期可以当作结束日期，但不能当作开始日期，故选择的日期的前一天是无效日期，返回
      // 如  2018-02-23，2018-02-24 为无效日期，则点击2018-02-24返回无效日期
      const isDisabledDate = isDisabled(date);
      const now = this.parse(date);
      const prevDate = new Date(
        now.getFullYear(),
        now.getMonth(),
        now.getDate() - 1
      );
      const prev = this.format(prevDate);
      const prevDateIsInValid = isDisabled(prev);
      const nextDate = new Date(
        now.getFullYear(),
        now.getMonth(),
        now.getDate() + 1
      );

      const next = this.format(nextDate);
      const nextDateIsInValid = isDisabled(next);
      if (
        (bindData && selected.length <= 0 && isDisabledDate) ||
        (isDoubleSelect &&
          prevDateIsInValid &&
          isDisabledDate &&
          nextDateIsInValid) ||
        (index >= 0 && isDisabledDate)
      ) {
        return {
          type: "disabled",
          value: []
        };
      }
      //重复选择
      //如选择了 2018-02-04 ~ 2018-02-06
      //但是用户实际想选择的是 2018-02-04~2018-02-05，
      //此时 用户再次选择 2018-02-04，其他日期将被删除
      if (index >= 0) {
        let peek = getPeek(selected);
        let front = getFront(selected);
        //如果选择的最后一个日期不是无效日期
        //则把最后一个日期保留，其他删除
        selected = isUndefined(this.state.disables[peek]) ? [peek] : [front];
      }
      //选择的日期数量超出了范围，置空selected
      if ((isDoubleSelect && selected.length >= 2) || !isDoubleSelect) {
        selected = [];
      }
      selected.push(date);
      if (!isDoubleSelect) {
        selected = isDisabledDate ? cache : selected;
        type = isDisabledDate ? "disabled" : "selected";
      } else {
        if (selected.length >= 2) {
          //两次选择的日期相同，选择
          let front = getFront(selected);
          let peek = getPeek(selected);
          const diffed = diff(
            this.parse(peek), //, this.state.dateFormat),
            this.parse(front), //, this.state.dateFormat),
            "days",
            false
          );
          if (diffed === 0) {
            selected = [front];
          } else if (diffed < 0) {
            peek = getPeek(selected);
            if (isDisabled(peek)) {
              selected.pop();
            } else {
              selected.shift();
            }
          } else {
            let range = this.getRange(selected);
            if (range.invalidDates.length > 0 || diffed > this.state.limit) {
              selected.shift();
            }
          }
        }
        // selected 长度为1 且 唯一的元素还是无效日期，则读取缓存
        if (selected.length <= 1) {
          if (isDisabled(getFront(selected))) {
            type = "disabled";
            selected = cache;
          }
        }
      }

      return {
        type,
        value: selected
      };
    };