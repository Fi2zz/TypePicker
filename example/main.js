/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./example/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/typepicker.development.js":
/*!****************************************!*\
  !*** ./dist/typepicker.development.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * TypePicker v6.1.5\n * 2019/8/2\n * A date picker use in web and react-native\n * (c) 2017-2019,Fi2zzz <wenjingbiao@outlook.com>\n * https://github.com/Fi2zz/TypePicker\n * MIT License\n */\nmodule.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar List = {\n  map: function map(input, _map) {\n    if (!List.isList(input)) {\n      return [];\n    }\n\n    return input.map(function (item, index) {\n      return _map(item, index);\n    });\n  },\n  create: function create(size, filled) {\n    filled = filled || undefined;\n    var list = [];\n\n    if (!size || size === 0) {\n      return list;\n    }\n\n    for (var i = 0; i < size; i++) {\n      list.push(filled ? typeof filled === \"function\" ? filled(i) : filled : i);\n    }\n\n    return list;\n  },\n  dedup: function dedup(list, key) {\n    var map = {};\n\n    if (list.length <= 0) {\n      return [];\n    }\n\n    return list.reduce(function (acc, currItem) {\n      var curr = currItem;\n\n      if (key) {\n        if (typeof key === \"function\") {\n          curr = key(curr, map);\n        } else {\n          curr = currItem[key];\n        }\n      }\n\n      if (!map[curr]) {\n        map[curr] = 1;\n        acc.push(curr);\n      }\n\n      return acc;\n    }, []);\n  },\n  loop: function loop(list, looper) {\n    for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {\n      var item = list_1[_i];\n      var index = list.indexOf(item);\n      looper(item, index, list);\n    }\n  },\n  every: function every(list, handler) {\n    if (!List.isList(list) || list.length <= 0) {\n      return false;\n    }\n\n    return list.every(handler);\n  },\n  findIndex: function findIndex(list, value) {\n    return list.indexOf(value);\n  },\n  isTop: function isTop(list, value) {\n    return List.findIndex(list, value) === 0;\n  },\n  isTail: function isTail(list, value) {\n    return List.findIndex(list, value) === List.length(list) - 1;\n  },\n  isList: function isList(list) {\n    return list instanceof Array;\n  },\n  includes: function includes(list, item) {\n    return List.findIndex(list, item) >= 0;\n  },\n  length: function length(list) {\n    return list.length;\n  }\n};\n\nvar pipe = function pipe(first) {\n  var more = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    more[_i - 1] = arguments[_i];\n  }\n\n  return more.reduce(function (acc, curr) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return curr(acc.apply(void 0, args));\n    };\n  }, first);\n};\n\nvar isPositiveInteger = function isPositiveInteger(input) {\n  return /^[1-9]?[0-9]+$/.test(\"\" + input);\n};\n\nvar isInterger = function isInterger(input) {\n  return /^(-)?[1-9]?[0-9]+$/.test(\"\" + input);\n};\n\nvar isBool = function isBool(v) {\n  return typeof v === \"boolean\";\n};\n\nvar genRandomNumber = function genRandomNumber() {\n  return (\"\" + Math.random() * 0x100000000).replace(\".\", \"-\");\n};\n\nvar PubSub = function () {\n  function PubSub(name) {\n    var _this = this;\n\n    this.name = \"observe\";\n    this.clientList = {};\n\n    this.subscribe = function (key, fn) {\n      var typeName = _this.getType(key);\n\n      if (!_this.clientList[typeName]) {\n        _this.clientList[typeName] = [];\n      }\n\n      _this.clientList[typeName].push(fn);\n    };\n\n    this.publish = function (type, args) {\n      Timex.delay(function () {\n        var fns = _this.clientList[_this.getType(type)];\n\n        if (!fns || fns.length === 0) {\n          return false;\n        }\n\n        for (var _i = 0, fns_1 = fns; _i < fns_1.length; _i++) {\n          var fn = fns_1[_i];\n          fn(args);\n        }\n      }, 1);\n    };\n\n    this.name = name;\n  }\n\n  PubSub.prototype.getType = function (type) {\n    return \"\" + this.name + type;\n  };\n\n  return PubSub;\n}();\n\nvar Selection = function () {\n  function Selection(value) {\n    this.value = value;\n  }\n\n  Selection.prototype.toString = function () {\n    return \"\" + +this.value + this.disabled;\n  };\n\n  return Selection;\n}();\n\nvar Queue = function () {\n  function Queue(size, canPushInvalid) {\n    var _this = this;\n\n    this.size = 1;\n    this.list = [];\n    this.canPushInvalid = false;\n\n    this.last = function () {\n      return _this.list[_this.length() - 1];\n    };\n\n    this.front = function () {\n      return _this.fetch(0);\n    };\n\n    this.length = function () {\n      return _this.list.length;\n    };\n\n    this.fetch = function (index) {\n      return index >= 0 ? _this.list[index] : _this.list;\n    };\n\n    this.isEmpty = function () {\n      return _this.length() <= 0;\n    };\n\n    this.isFullFilled = function () {\n      return _this.length() === _this.size;\n    };\n\n    this.clean = function () {\n      return _this.list = [];\n    };\n\n    this.shift = function () {\n      return _this.list.shift();\n    };\n\n    this.pop = function () {\n      return _this.list.pop();\n    };\n\n    this.push = function (data) {\n      return function (afterPush) {\n        var before = _this.list.filter(function (item) {\n          return item.toString() === data.toString();\n        });\n\n        if (before.length > 0) {\n          if (_this.length() === 1) {\n            return;\n          }\n\n          if (_this.size === 2) {\n            _this.shift();\n          } else {\n            _this.clean();\n          }\n        }\n\n        _this.list.push(data);\n\n        Timex.delay(afterPush);\n      };\n    };\n\n    this.size = size;\n    this.canPushInvalid = canPushInvalid;\n  }\n\n  return Queue;\n}();\n\nvar TimeX = function () {\n  function TimeX() {\n    this.millisecondsOfDate = 1000 * 60 * 60 * 24;\n\n    this.isDate = function (object) {\n      return object instanceof Date;\n    };\n  }\n\n  TimeX.prototype.diff = function (first, second, type, isAbsolute) {\n    if (type === void 0) {\n      type = \"days\";\n    }\n\n    var result;\n\n    if (!Timex.isDate(first) || !Timex.isDate(second)) {\n      return 0;\n    }\n\n    var that = this;\n    var components = {\n      start: that.dateComponents(first),\n      end: that.dateComponents(second)\n    };\n\n    if (type === \"month\") {\n      result = Math.abs(components.start.year * 12 + components.start.month) - (components.end.year * 12 + components.end.month);\n    } else if (type === \"days\") {\n      result = Math.ceil(components.start.time - components.end.time) / Timex.millisecondsOfDate;\n    }\n\n    return isAbsolute ? Math.abs(result) : result;\n  };\n\n  TimeX.prototype.delay = function (handler, duration) {\n    if (duration === void 0) {\n      duration = 0;\n    }\n\n    var delayed = setTimeout(function () {\n      handler();\n      clearTimeout(delayed);\n    }, duration);\n  };\n\n  TimeX.prototype.dateComponents = function (input) {\n    var month = input.getMonth();\n    var year = input.getFullYear();\n    var date = input.getDate();\n    var day = input.getDay();\n    var hours = input.getHours();\n    var minutes = input.getMinutes();\n    var seconds = input.getSeconds();\n    var ms = input.getMilliseconds();\n    var dateString = input.toDateString();\n    var isoString = input.toISOString();\n    var time = input.getTime();\n    var timezoneOffset = input.getTimezoneOffset();\n    return {\n      year: year,\n      date: date,\n      month: month,\n      day: day,\n      hours: hours,\n      minutes: minutes,\n      seconds: seconds,\n      ms: ms,\n      milliseconds: ms,\n      dateString: dateString,\n      isoString: isoString,\n      time: time,\n      timezoneOffset: timezoneOffset\n    };\n  };\n\n  TimeX.prototype.createDate = function (options) {\n    var year = options.year,\n        month = options.month,\n        date = options.date,\n        _a = options.minutes,\n        minutes = _a === void 0 ? 0 : _a,\n        _b = options.hours,\n        hours = _b === void 0 ? 0 : _b,\n        _c = options.seconds,\n        seconds = _c === void 0 ? 0 : _c,\n        _d = options.milliseconds,\n        milliseconds = _d === void 0 ? 0 : _d;\n    return new Date(year, month, date, hours, minutes, seconds, milliseconds);\n  };\n\n  TimeX.prototype.today = function () {\n    var date = new Date();\n    var components = this.dateComponents(date);\n    return this.createDate({\n      year: components.year,\n      month: components.month,\n      date: components.date\n    });\n  };\n\n  return TimeX;\n}();\n\nvar Timex = new TimeX();\n\nfunction genTypePickerData(mapRange, mapDisables) {\n  return function (size, date) {\n    var genCalendar = function genCalendar(_a) {\n      var size = _a.size,\n          date = _a.date;\n      return List.create(size, function (index) {\n        var components = Timex.dateComponents(date);\n        components.month += index;\n        var firstDate = Timex.createDate(__assign({}, components, {\n          date: 1\n        }));\n        var endDate = Timex.createDate(__assign({}, components, {\n          month: components.month + 1,\n          date: 0\n        }));\n        return __assign({}, Timex.dateComponents(firstDate), {\n          dates: Timex.dateComponents(endDate).date,\n          endDate: endDate,\n          firstDate: firstDate\n        });\n      });\n    };\n\n    var genDates = function genDates(calendars) {\n      return List.map(calendars, function (_a) {\n        var day = _a.day,\n            year = _a.year,\n            month = _a.month,\n            endDate = _a.endDate,\n            firstDate = _a.firstDate;\n        return {\n          year: year,\n          month: month,\n          dates: List.create(42, function (index) {\n            var date = Timex.createDate({\n              year: year,\n              month: month,\n              date: index - day + 1\n            });\n            var components = Timex.dateComponents(date);\n            var invalid = date > endDate || date < firstDate;\n            return {\n              date: date,\n              invalid: invalid,\n              disabled: invalid || mapDisables(date),\n              status: mapRange(components.dateString)\n            };\n          })\n        };\n      });\n    };\n\n    var genSize = function genSize(_a) {\n      var size = _a.size,\n          date = _a.date;\n      return {\n        size: size >= 0 ? size : size * -1,\n        date: date\n      };\n    };\n\n    return pipe(genSize, genCalendar, genDates)({\n      size: size,\n      date: date\n    });\n  };\n}\n\nfunction checkQueue(queue, disabled, unpushable, popable) {\n  var currentQueueLength = queue.length();\n  var nextQueueLength = currentQueueLength + 1;\n\n  if (disabled) {\n    if (queue.size !== 2 || queue.size === 2 && (currentQueueLength === 1 && unpushable() || queue.isEmpty() || queue.isFullFilled() || !queue.canPushInvalid)) {\n      return false;\n    }\n  } else if (queue.size === 2) {\n    if (currentQueueLength) {\n      if (unpushable()) {\n        queue.shift();\n      } else if (popable()) {\n        queue.pop();\n      }\n    }\n  }\n\n  if (nextQueueLength > queue.size) {\n    queue.clean();\n  }\n\n  return true;\n}\n\nfunction setDatesDedupe(date, map) {\n  if (!map[date.toDateString()]) {\n    return date;\n  }\n\n  return null;\n}\n\nfunction getOptions(option) {\n  option = option || {};\n  var partial = {};\n\n  if (isInterger(option.size)) {\n    partial.size = option.size;\n  }\n\n  if (isPositiveInteger(option.selection)) {\n    partial.selection = option.selection;\n  }\n\n  if (isBool(option.useInvalidAsSelected)) {\n    partial.useInvalidAsSelected = option.useInvalidAsSelected;\n\n    if (option.useInvalidAsSelected === true) {\n      partial.selection = 2;\n    }\n  }\n\n  return partial;\n}\n\nvar mapStatusOfDate = function mapStatusOfDate(range, useRange) {\n  return function (dateString) {\n    var length = range.length();\n    var status = {\n      isActive: false,\n      isEnd: false,\n      isStart: false,\n      inRange: false\n    };\n\n    if (length <= 0) {\n      return status;\n    }\n\n    var dateToString = function dateToString(date) {\n      return Timex.dateComponents(date).dateString;\n    };\n\n    if (!useRange) {\n      status.isActive = pipe(function (data) {\n        return List.map(data, function (item) {\n          return item.value;\n        });\n      }, function (data) {\n        return List.map(data, dateToString);\n      }, function (data) {\n        return List.includes(data, dateString);\n      })(range.fetch());\n    } else {\n      var first_1 = range.fetch(0);\n      var last = range.fetch(range.length() - 1);\n      var getRange = pipe(function ($1, $2) {\n        return Timex.diff($1, $2, \"days\", true);\n      }, function (size) {\n        return List.create(size + 1);\n      }, function (range) {\n        return List.map(range, function (item) {\n          var components = Timex.dateComponents(first_1.value);\n          components.date += item;\n          var date = Timex.createDate(components);\n          return dateToString(date);\n        });\n      });\n      var data = getRange(last.value, first_1.value);\n      status.isActive = List.isTop(data, dateString) || List.isTail(data, dateString);\n      status.inRange = List.includes(data, dateString);\n      status.isStart = List.isTop(data, dateString);\n      status.isEnd = List.isTail(data, dateString);\n\n      if (status.isStart || status.isEnd) {\n        status.inRange = false;\n      }\n    }\n\n    return status;\n  };\n};\n\nvar Updater = function () {\n  function Updater(config) {\n    var _this = this;\n\n    this.pubsub = new PubSub(genRandomNumber());\n\n    this.update = function (date, selectedValue) {\n      if (date) {\n        _this.config.date = date;\n      }\n\n      var createData = pipe(genTypePickerData(mapStatusOfDate(_this.queue, _this.config.selection === 2), _this.disables.find));\n\n      _this.pubsub.publish(TypePickerListenerTypes.update, createData(_this.config.size, _this.config.date));\n\n      if (List.isList(selectedValue)) {\n        _this.pubsub.publish(TypePickerListenerTypes.select, List.map(selectedValue, function (item) {\n          return item.value;\n        }));\n      }\n    };\n\n    this.queue = null;\n    this.data = [];\n    this.disables = {\n      find: function find(date) {\n        return false;\n      }\n    };\n    this.config = config;\n    this.queue = new Queue(config.selection, config.useInvalidAsSelected);\n  }\n\n  Updater.prototype.checkQueue = function (item) {\n    var queue = this.queue;\n    var disables = this.disables;\n    var current = item.value;\n    var last = queue.last();\n    var first = queue.front();\n\n    var unpushable = function unpushable() {\n      if (item.disabled && current < last.value) {\n        return true;\n      }\n\n      var getSize = function getSize(_a) {\n        var current = _a[0],\n            first = _a[1];\n        return [Timex.diff(current, first, \"days\", true), first];\n      };\n\n      var create = function create(date) {\n        return function (index) {\n          var components = Timex.dateComponents(date);\n          components.date += index;\n          return Timex.createDate(components);\n        };\n      };\n\n      var findDates = function findDates(_a) {\n        var size = _a[0],\n            date = _a[1];\n        return List.create(size, create(date));\n      };\n\n      var findDisables = function findDisables(dates) {\n        return List.map(dates, function (date) {\n          return disables.find(date) && Timex.dateComponents(date).time !== Timex.dateComponents(current).time;\n        });\n      };\n\n      var filterTrue = function filterTrue(data) {\n        return data.filter(function (item) {\n          return item === true;\n        });\n      };\n\n      var has = function has(data) {\n        return List.length(data) > 0;\n      };\n\n      return pipe(getSize, findDates, findDisables, filterTrue, has)([item.value, first.value]);\n    };\n\n    var popable = function popable() {\n      return first.value > current;\n    };\n\n    return checkQueue(queue, item.disabled, unpushable, popable);\n  };\n\n  Updater.prototype.push = function (date, cleanQueue) {\n    var _this = this;\n\n    if (cleanQueue === void 0) {\n      cleanQueue = false;\n    }\n\n    var createItem = function createItem(value) {\n      if (!Timex.isDate(value)) {\n        console.error(\"Error: expected Date object, but got \" + value + \" \");\n        return;\n      }\n\n      var components = Timex.dateComponents(value);\n      var date = Timex.createDate(components);\n      var select = new Selection(date);\n      select.disabled = _this.disables.find(date);\n      return select;\n    };\n\n    var data = List.isList(date) ? date : [date];\n\n    if (cleanQueue) {\n      this.queue.clean();\n      this.data = [];\n    }\n\n    this.data = List.map(data, createItem);\n\n    if (List.length(this.data) <= 0) {\n      this.update(null, []);\n    }\n\n    List.loop(this.data, function (item) {\n      Timex.delay(function () {\n        item.disabled = _this.disables.find(item.value);\n      }, 0);\n\n      var canPush = _this.checkQueue(item);\n\n      var callUpdate = function callUpdate() {\n        return _this.update(null, _this.queue.fetch());\n      };\n\n      if (canPush) {\n        _this.queue.push(item)(callUpdate);\n      }\n    });\n  };\n\n  return Updater;\n}();\n\nvar TypePickerListenerTypes = {\n  update: \"update\",\n  select: \"select\"\n};\n\nfunction TypePicker(option) {\n  var _this = this;\n\n  var updater = new Updater(__assign({\n    selection: 1,\n    date: Timex.today(),\n    useInvalidAsSelected: false,\n    size: 1\n  }, getOptions(option)));\n\n  var applyDates = function applyDates(dates) {\n    var setDates = pipe(function (dates) {\n      return dates.slice(0, updater.config.selection);\n    }, function (dates) {\n      return dates.filter(Timex.isDate);\n    }, function (dates) {\n      return List.dedup(dates, setDatesDedupe);\n    }, function (dates) {\n      return List.every(dates, Timex.isDate) ? dates : [];\n    }, function (dates) {\n      return dates.sort(function (t1, t2) {\n        return +t1 - +t2;\n      });\n    });\n    Timex.delay(function () {\n      updater.push(setDates(dates), true);\n    });\n  };\n\n  this.listen = function (next) {\n    updater.pubsub.subscribe(TypePickerListenerTypes.update, function (payload) {\n      return next({\n        type: TypePickerListenerTypes.update,\n        payload: payload,\n        types: TypePickerListenerTypes\n      });\n    });\n    updater.pubsub.subscribe(TypePickerListenerTypes.select, function (payload) {\n      return next({\n        type: TypePickerListenerTypes.select,\n        payload: payload,\n        types: TypePickerListenerTypes\n      });\n    });\n  };\n\n  var select = function select(date) {\n    if (List.isList(date)) {\n      date = date.pop();\n    }\n\n    updater.push(date);\n  };\n\n  this.apply = {\n    dates: applyDates,\n    disableDate: function disableDate(handler) {\n      return updater.disables.find = handler;\n    },\n    date: function date(_date) {\n      return updater.update(_date, null);\n    },\n    update: function update() {\n      return updater.update(null, null);\n    },\n    select: select\n  };\n  Timex.delay(function () {\n    _this.apply.select(updater.config.date, true);\n  });\n}\n\nexports[\"default\"] = TypePicker;\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kaXN0L3R5cGVwaWNrZXIuZGV2ZWxvcG1lbnQuanM/ZWRlOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0NBQWdDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxrQkFBa0I7QUFDbEY7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQ0FBaUM7QUFDbEYsd0hBQXdILG1CQUFtQixFQUFFO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEIsRUFBRTtBQUMvRCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtEQUErRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxtQ0FBbUMsb0JBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLFNBQVM7QUFDVCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLFNBQVM7QUFDVCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSxPQUFPO0FBQ1AiLCJmaWxlIjoiLi9kaXN0L3R5cGVwaWNrZXIuZGV2ZWxvcG1lbnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFR5cGVQaWNrZXIgdjYuMS41XG4gKiAyMDE5LzgvMlxuICogQSBkYXRlIHBpY2tlciB1c2UgaW4gd2ViIGFuZCByZWFjdC1uYXRpdmVcbiAqIChjKSAyMDE3LTIwMTksRmkyenp6IDx3ZW5qaW5nYmlhb0BvdXRsb29rLmNvbT5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9GaTJ6ei9UeXBlUGlja2VyXG4gKiBNSVQgTGljZW5zZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9fYXNzaWduID0gdGhpcyAmJiB0aGlzLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIExpc3QgPSB7XG4gIG1hcDogZnVuY3Rpb24gbWFwKGlucHV0LCBfbWFwKSB7XG4gICAgaWYgKCFMaXN0LmlzTGlzdChpbnB1dCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5wdXQubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIF9tYXAoaXRlbSwgaW5kZXgpO1xuICAgIH0pO1xuICB9LFxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShzaXplLCBmaWxsZWQpIHtcbiAgICBmaWxsZWQgPSBmaWxsZWQgfHwgdW5kZWZpbmVkO1xuICAgIHZhciBsaXN0ID0gW107XG5cbiAgICBpZiAoIXNpemUgfHwgc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGxpc3QucHVzaChmaWxsZWQgPyB0eXBlb2YgZmlsbGVkID09PSBcImZ1bmN0aW9uXCIgPyBmaWxsZWQoaSkgOiBmaWxsZWQgOiBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfSxcbiAgZGVkdXA6IGZ1bmN0aW9uIGRlZHVwKGxpc3QsIGtleSkge1xuICAgIHZhciBtYXAgPSB7fTtcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3QucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnJJdGVtKSB7XG4gICAgICB2YXIgY3VyciA9IGN1cnJJdGVtO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjdXJyID0ga2V5KGN1cnIsIG1hcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyciA9IGN1cnJJdGVtW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXBbY3Vycl0pIHtcbiAgICAgICAgbWFwW2N1cnJdID0gMTtcbiAgICAgICAgYWNjLnB1c2goY3Vycik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICB9LFxuICBsb29wOiBmdW5jdGlvbiBsb29wKGxpc3QsIGxvb3Blcikge1xuICAgIGZvciAodmFyIF9pID0gMCwgbGlzdF8xID0gbGlzdDsgX2kgPCBsaXN0XzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGxpc3RfMVtfaV07XG4gICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoaXRlbSk7XG4gICAgICBsb29wZXIoaXRlbSwgaW5kZXgsIGxpc3QpO1xuICAgIH1cbiAgfSxcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGxpc3QsIGhhbmRsZXIpIHtcbiAgICBpZiAoIUxpc3QuaXNMaXN0KGxpc3QpIHx8IGxpc3QubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdC5ldmVyeShoYW5kbGVyKTtcbiAgfSxcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgobGlzdCwgdmFsdWUpIHtcbiAgICByZXR1cm4gbGlzdC5pbmRleE9mKHZhbHVlKTtcbiAgfSxcbiAgaXNUb3A6IGZ1bmN0aW9uIGlzVG9wKGxpc3QsIHZhbHVlKSB7XG4gICAgcmV0dXJuIExpc3QuZmluZEluZGV4KGxpc3QsIHZhbHVlKSA9PT0gMDtcbiAgfSxcbiAgaXNUYWlsOiBmdW5jdGlvbiBpc1RhaWwobGlzdCwgdmFsdWUpIHtcbiAgICByZXR1cm4gTGlzdC5maW5kSW5kZXgobGlzdCwgdmFsdWUpID09PSBMaXN0Lmxlbmd0aChsaXN0KSAtIDE7XG4gIH0sXG4gIGlzTGlzdDogZnVuY3Rpb24gaXNMaXN0KGxpc3QpIHtcbiAgICByZXR1cm4gbGlzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9LFxuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMobGlzdCwgaXRlbSkge1xuICAgIHJldHVybiBMaXN0LmZpbmRJbmRleChsaXN0LCBpdGVtKSA+PSAwO1xuICB9LFxuICBsZW5ndGg6IGZ1bmN0aW9uIGxlbmd0aChsaXN0KSB7XG4gICAgcmV0dXJuIGxpc3QubGVuZ3RoO1xuICB9XG59O1xuXG52YXIgcGlwZSA9IGZ1bmN0aW9uIHBpcGUoZmlyc3QpIHtcbiAgdmFyIG1vcmUgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIG1vcmVbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cblxuICByZXR1cm4gbW9yZS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3Vycikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyKGFjYy5hcHBseSh2b2lkIDAsIGFyZ3MpKTtcbiAgICB9O1xuICB9LCBmaXJzdCk7XG59O1xuXG52YXIgaXNQb3NpdGl2ZUludGVnZXIgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlSW50ZWdlcihpbnB1dCkge1xuICByZXR1cm4gL15bMS05XT9bMC05XSskLy50ZXN0KFwiXCIgKyBpbnB1dCk7XG59O1xuXG52YXIgaXNJbnRlcmdlciA9IGZ1bmN0aW9uIGlzSW50ZXJnZXIoaW5wdXQpIHtcbiAgcmV0dXJuIC9eKC0pP1sxLTldP1swLTldKyQvLnRlc3QoXCJcIiArIGlucHV0KTtcbn07XG5cbnZhciBpc0Jvb2wgPSBmdW5jdGlvbiBpc0Jvb2wodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwiYm9vbGVhblwiO1xufTtcblxudmFyIGdlblJhbmRvbU51bWJlciA9IGZ1bmN0aW9uIGdlblJhbmRvbU51bWJlcigpIHtcbiAgcmV0dXJuIChcIlwiICsgTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKS5yZXBsYWNlKFwiLlwiLCBcIi1cIik7XG59O1xuXG52YXIgUHViU3ViID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQdWJTdWIobmFtZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLm5hbWUgPSBcIm9ic2VydmVcIjtcbiAgICB0aGlzLmNsaWVudExpc3QgPSB7fTtcblxuICAgIHRoaXMuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGtleSwgZm4pIHtcbiAgICAgIHZhciB0eXBlTmFtZSA9IF90aGlzLmdldFR5cGUoa2V5KTtcblxuICAgICAgaWYgKCFfdGhpcy5jbGllbnRMaXN0W3R5cGVOYW1lXSkge1xuICAgICAgICBfdGhpcy5jbGllbnRMaXN0W3R5cGVOYW1lXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5jbGllbnRMaXN0W3R5cGVOYW1lXS5wdXNoKGZuKTtcbiAgICB9O1xuXG4gICAgdGhpcy5wdWJsaXNoID0gZnVuY3Rpb24gKHR5cGUsIGFyZ3MpIHtcbiAgICAgIFRpbWV4LmRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZucyA9IF90aGlzLmNsaWVudExpc3RbX3RoaXMuZ2V0VHlwZSh0eXBlKV07XG5cbiAgICAgICAgaWYgKCFmbnMgfHwgZm5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZm5zXzEgPSBmbnM7IF9pIDwgZm5zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIGZuID0gZm5zXzFbX2ldO1xuICAgICAgICAgIGZuKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9LCAxKTtcbiAgICB9O1xuXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuXG4gIFB1YlN1Yi5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgcmV0dXJuIFwiXCIgKyB0aGlzLm5hbWUgKyB0eXBlO1xuICB9O1xuXG4gIHJldHVybiBQdWJTdWI7XG59KCk7XG5cbnZhciBTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNlbGVjdGlvbih2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiXCIgKyArdGhpcy52YWx1ZSArIHRoaXMuZGlzYWJsZWQ7XG4gIH07XG5cbiAgcmV0dXJuIFNlbGVjdGlvbjtcbn0oKTtcblxudmFyIFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBRdWV1ZShzaXplLCBjYW5QdXNoSW52YWxpZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLnNpemUgPSAxO1xuICAgIHRoaXMubGlzdCA9IFtdO1xuICAgIHRoaXMuY2FuUHVzaEludmFsaWQgPSBmYWxzZTtcblxuICAgIHRoaXMubGFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5saXN0W190aGlzLmxlbmd0aCgpIC0gMV07XG4gICAgfTtcblxuICAgIHRoaXMuZnJvbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZmV0Y2goMCk7XG4gICAgfTtcblxuICAgIHRoaXMubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmxpc3QubGVuZ3RoO1xuICAgIH07XG5cbiAgICB0aGlzLmZldGNoID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXggPj0gMCA/IF90aGlzLmxpc3RbaW5kZXhdIDogX3RoaXMubGlzdDtcbiAgICB9O1xuXG4gICAgdGhpcy5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmxlbmd0aCgpIDw9IDA7XG4gICAgfTtcblxuICAgIHRoaXMuaXNGdWxsRmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmxlbmd0aCgpID09PSBfdGhpcy5zaXplO1xuICAgIH07XG5cbiAgICB0aGlzLmNsZWFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmxpc3QgPSBbXTtcbiAgICB9O1xuXG4gICAgdGhpcy5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5saXN0LnNoaWZ0KCk7XG4gICAgfTtcblxuICAgIHRoaXMucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmxpc3QucG9wKCk7XG4gICAgfTtcblxuICAgIHRoaXMucHVzaCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFmdGVyUHVzaCkge1xuICAgICAgICB2YXIgYmVmb3JlID0gX3RoaXMubGlzdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZygpID09PSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChiZWZvcmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChfdGhpcy5sZW5ndGgoKSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdGhpcy5zaXplID09PSAyKSB7XG4gICAgICAgICAgICBfdGhpcy5zaGlmdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5jbGVhbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmxpc3QucHVzaChkYXRhKTtcblxuICAgICAgICBUaW1leC5kZWxheShhZnRlclB1c2gpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmNhblB1c2hJbnZhbGlkID0gY2FuUHVzaEludmFsaWQ7XG4gIH1cblxuICByZXR1cm4gUXVldWU7XG59KCk7XG5cbnZhciBUaW1lWCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGltZVgoKSB7XG4gICAgdGhpcy5taWxsaXNlY29uZHNPZkRhdGUgPSAxMDAwICogNjAgKiA2MCAqIDI0O1xuXG4gICAgdGhpcy5pc0RhdGUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgRGF0ZTtcbiAgICB9O1xuICB9XG5cbiAgVGltZVgucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCwgdHlwZSwgaXNBYnNvbHV0ZSkge1xuICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgIHR5cGUgPSBcImRheXNcIjtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKCFUaW1leC5pc0RhdGUoZmlyc3QpIHx8ICFUaW1leC5pc0RhdGUoc2Vjb25kKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBjb21wb25lbnRzID0ge1xuICAgICAgc3RhcnQ6IHRoYXQuZGF0ZUNvbXBvbmVudHMoZmlyc3QpLFxuICAgICAgZW5kOiB0aGF0LmRhdGVDb21wb25lbnRzKHNlY29uZClcbiAgICB9O1xuXG4gICAgaWYgKHR5cGUgPT09IFwibW9udGhcIikge1xuICAgICAgcmVzdWx0ID0gTWF0aC5hYnMoY29tcG9uZW50cy5zdGFydC55ZWFyICogMTIgKyBjb21wb25lbnRzLnN0YXJ0Lm1vbnRoKSAtIChjb21wb25lbnRzLmVuZC55ZWFyICogMTIgKyBjb21wb25lbnRzLmVuZC5tb250aCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRheXNcIikge1xuICAgICAgcmVzdWx0ID0gTWF0aC5jZWlsKGNvbXBvbmVudHMuc3RhcnQudGltZSAtIGNvbXBvbmVudHMuZW5kLnRpbWUpIC8gVGltZXgubWlsbGlzZWNvbmRzT2ZEYXRlO1xuICAgIH1cblxuICAgIHJldHVybiBpc0Fic29sdXRlID8gTWF0aC5hYnMocmVzdWx0KSA6IHJlc3VsdDtcbiAgfTtcblxuICBUaW1lWC5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAoaGFuZGxlciwgZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZHVyYXRpb24gPSAwO1xuICAgIH1cblxuICAgIHZhciBkZWxheWVkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBoYW5kbGVyKCk7XG4gICAgICBjbGVhclRpbWVvdXQoZGVsYXllZCk7XG4gICAgfSwgZHVyYXRpb24pO1xuICB9O1xuXG4gIFRpbWVYLnByb3RvdHlwZS5kYXRlQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBtb250aCA9IGlucHV0LmdldE1vbnRoKCk7XG4gICAgdmFyIHllYXIgPSBpbnB1dC5nZXRGdWxsWWVhcigpO1xuICAgIHZhciBkYXRlID0gaW5wdXQuZ2V0RGF0ZSgpO1xuICAgIHZhciBkYXkgPSBpbnB1dC5nZXREYXkoKTtcbiAgICB2YXIgaG91cnMgPSBpbnB1dC5nZXRIb3VycygpO1xuICAgIHZhciBtaW51dGVzID0gaW5wdXQuZ2V0TWludXRlcygpO1xuICAgIHZhciBzZWNvbmRzID0gaW5wdXQuZ2V0U2Vjb25kcygpO1xuICAgIHZhciBtcyA9IGlucHV0LmdldE1pbGxpc2Vjb25kcygpO1xuICAgIHZhciBkYXRlU3RyaW5nID0gaW5wdXQudG9EYXRlU3RyaW5nKCk7XG4gICAgdmFyIGlzb1N0cmluZyA9IGlucHV0LnRvSVNPU3RyaW5nKCk7XG4gICAgdmFyIHRpbWUgPSBpbnB1dC5nZXRUaW1lKCk7XG4gICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gaW5wdXQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgeWVhcjogeWVhcixcbiAgICAgIGRhdGU6IGRhdGUsXG4gICAgICBtb250aDogbW9udGgsXG4gICAgICBkYXk6IGRheSxcbiAgICAgIGhvdXJzOiBob3VycyxcbiAgICAgIG1pbnV0ZXM6IG1pbnV0ZXMsXG4gICAgICBzZWNvbmRzOiBzZWNvbmRzLFxuICAgICAgbXM6IG1zLFxuICAgICAgbWlsbGlzZWNvbmRzOiBtcyxcbiAgICAgIGRhdGVTdHJpbmc6IGRhdGVTdHJpbmcsXG4gICAgICBpc29TdHJpbmc6IGlzb1N0cmluZyxcbiAgICAgIHRpbWU6IHRpbWUsXG4gICAgICB0aW1lem9uZU9mZnNldDogdGltZXpvbmVPZmZzZXRcbiAgICB9O1xuICB9O1xuXG4gIFRpbWVYLnByb3RvdHlwZS5jcmVhdGVEYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgeWVhciA9IG9wdGlvbnMueWVhcixcbiAgICAgICAgbW9udGggPSBvcHRpb25zLm1vbnRoLFxuICAgICAgICBkYXRlID0gb3B0aW9ucy5kYXRlLFxuICAgICAgICBfYSA9IG9wdGlvbnMubWludXRlcyxcbiAgICAgICAgbWludXRlcyA9IF9hID09PSB2b2lkIDAgPyAwIDogX2EsXG4gICAgICAgIF9iID0gb3B0aW9ucy5ob3VycyxcbiAgICAgICAgaG91cnMgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLFxuICAgICAgICBfYyA9IG9wdGlvbnMuc2Vjb25kcyxcbiAgICAgICAgc2Vjb25kcyA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsXG4gICAgICAgIF9kID0gb3B0aW9ucy5taWxsaXNlY29uZHMsXG4gICAgICAgIG1pbGxpc2Vjb25kcyA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzKTtcbiAgfTtcblxuICBUaW1lWC5wcm90b3R5cGUudG9kYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5kYXRlQ29tcG9uZW50cyhkYXRlKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVEYXRlKHtcbiAgICAgIHllYXI6IGNvbXBvbmVudHMueWVhcixcbiAgICAgIG1vbnRoOiBjb21wb25lbnRzLm1vbnRoLFxuICAgICAgZGF0ZTogY29tcG9uZW50cy5kYXRlXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVYO1xufSgpO1xuXG52YXIgVGltZXggPSBuZXcgVGltZVgoKTtcblxuZnVuY3Rpb24gZ2VuVHlwZVBpY2tlckRhdGEobWFwUmFuZ2UsIG1hcERpc2FibGVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc2l6ZSwgZGF0ZSkge1xuICAgIHZhciBnZW5DYWxlbmRhciA9IGZ1bmN0aW9uIGdlbkNhbGVuZGFyKF9hKSB7XG4gICAgICB2YXIgc2l6ZSA9IF9hLnNpemUsXG4gICAgICAgICAgZGF0ZSA9IF9hLmRhdGU7XG4gICAgICByZXR1cm4gTGlzdC5jcmVhdGUoc2l6ZSwgZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gVGltZXguZGF0ZUNvbXBvbmVudHMoZGF0ZSk7XG4gICAgICAgIGNvbXBvbmVudHMubW9udGggKz0gaW5kZXg7XG4gICAgICAgIHZhciBmaXJzdERhdGUgPSBUaW1leC5jcmVhdGVEYXRlKF9fYXNzaWduKHt9LCBjb21wb25lbnRzLCB7XG4gICAgICAgICAgZGF0ZTogMVxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBlbmREYXRlID0gVGltZXguY3JlYXRlRGF0ZShfX2Fzc2lnbih7fSwgY29tcG9uZW50cywge1xuICAgICAgICAgIG1vbnRoOiBjb21wb25lbnRzLm1vbnRoICsgMSxcbiAgICAgICAgICBkYXRlOiAwXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCBUaW1leC5kYXRlQ29tcG9uZW50cyhmaXJzdERhdGUpLCB7XG4gICAgICAgICAgZGF0ZXM6IFRpbWV4LmRhdGVDb21wb25lbnRzKGVuZERhdGUpLmRhdGUsXG4gICAgICAgICAgZW5kRGF0ZTogZW5kRGF0ZSxcbiAgICAgICAgICBmaXJzdERhdGU6IGZpcnN0RGF0ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgZ2VuRGF0ZXMgPSBmdW5jdGlvbiBnZW5EYXRlcyhjYWxlbmRhcnMpIHtcbiAgICAgIHJldHVybiBMaXN0Lm1hcChjYWxlbmRhcnMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZGF5ID0gX2EuZGF5LFxuICAgICAgICAgICAgeWVhciA9IF9hLnllYXIsXG4gICAgICAgICAgICBtb250aCA9IF9hLm1vbnRoLFxuICAgICAgICAgICAgZW5kRGF0ZSA9IF9hLmVuZERhdGUsXG4gICAgICAgICAgICBmaXJzdERhdGUgPSBfYS5maXJzdERhdGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICBtb250aDogbW9udGgsXG4gICAgICAgICAgZGF0ZXM6IExpc3QuY3JlYXRlKDQyLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gVGltZXguY3JlYXRlRGF0ZSh7XG4gICAgICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgICAgICAgICAgZGF0ZTogaW5kZXggLSBkYXkgKyAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gVGltZXguZGF0ZUNvbXBvbmVudHMoZGF0ZSk7XG4gICAgICAgICAgICB2YXIgaW52YWxpZCA9IGRhdGUgPiBlbmREYXRlIHx8IGRhdGUgPCBmaXJzdERhdGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICAgICAgICBpbnZhbGlkOiBpbnZhbGlkLFxuICAgICAgICAgICAgICBkaXNhYmxlZDogaW52YWxpZCB8fCBtYXBEaXNhYmxlcyhkYXRlKSxcbiAgICAgICAgICAgICAgc3RhdHVzOiBtYXBSYW5nZShjb21wb25lbnRzLmRhdGVTdHJpbmcpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGdlblNpemUgPSBmdW5jdGlvbiBnZW5TaXplKF9hKSB7XG4gICAgICB2YXIgc2l6ZSA9IF9hLnNpemUsXG4gICAgICAgICAgZGF0ZSA9IF9hLmRhdGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaXplOiBzaXplID49IDAgPyBzaXplIDogc2l6ZSAqIC0xLFxuICAgICAgICBkYXRlOiBkYXRlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gcGlwZShnZW5TaXplLCBnZW5DYWxlbmRhciwgZ2VuRGF0ZXMpKHtcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBkYXRlOiBkYXRlXG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNoZWNrUXVldWUocXVldWUsIGRpc2FibGVkLCB1bnB1c2hhYmxlLCBwb3BhYmxlKSB7XG4gIHZhciBjdXJyZW50UXVldWVMZW5ndGggPSBxdWV1ZS5sZW5ndGgoKTtcbiAgdmFyIG5leHRRdWV1ZUxlbmd0aCA9IGN1cnJlbnRRdWV1ZUxlbmd0aCArIDE7XG5cbiAgaWYgKGRpc2FibGVkKSB7XG4gICAgaWYgKHF1ZXVlLnNpemUgIT09IDIgfHwgcXVldWUuc2l6ZSA9PT0gMiAmJiAoY3VycmVudFF1ZXVlTGVuZ3RoID09PSAxICYmIHVucHVzaGFibGUoKSB8fCBxdWV1ZS5pc0VtcHR5KCkgfHwgcXVldWUuaXNGdWxsRmlsbGVkKCkgfHwgIXF1ZXVlLmNhblB1c2hJbnZhbGlkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChxdWV1ZS5zaXplID09PSAyKSB7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZUxlbmd0aCkge1xuICAgICAgaWYgKHVucHVzaGFibGUoKSkge1xuICAgICAgICBxdWV1ZS5zaGlmdCgpO1xuICAgICAgfSBlbHNlIGlmIChwb3BhYmxlKCkpIHtcbiAgICAgICAgcXVldWUucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG5leHRRdWV1ZUxlbmd0aCA+IHF1ZXVlLnNpemUpIHtcbiAgICBxdWV1ZS5jbGVhbigpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNldERhdGVzRGVkdXBlKGRhdGUsIG1hcCkge1xuICBpZiAoIW1hcFtkYXRlLnRvRGF0ZVN0cmluZygpXSkge1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0aW9uKSB7XG4gIG9wdGlvbiA9IG9wdGlvbiB8fCB7fTtcbiAgdmFyIHBhcnRpYWwgPSB7fTtcblxuICBpZiAoaXNJbnRlcmdlcihvcHRpb24uc2l6ZSkpIHtcbiAgICBwYXJ0aWFsLnNpemUgPSBvcHRpb24uc2l6ZTtcbiAgfVxuXG4gIGlmIChpc1Bvc2l0aXZlSW50ZWdlcihvcHRpb24uc2VsZWN0aW9uKSkge1xuICAgIHBhcnRpYWwuc2VsZWN0aW9uID0gb3B0aW9uLnNlbGVjdGlvbjtcbiAgfVxuXG4gIGlmIChpc0Jvb2wob3B0aW9uLnVzZUludmFsaWRBc1NlbGVjdGVkKSkge1xuICAgIHBhcnRpYWwudXNlSW52YWxpZEFzU2VsZWN0ZWQgPSBvcHRpb24udXNlSW52YWxpZEFzU2VsZWN0ZWQ7XG5cbiAgICBpZiAob3B0aW9uLnVzZUludmFsaWRBc1NlbGVjdGVkID09PSB0cnVlKSB7XG4gICAgICBwYXJ0aWFsLnNlbGVjdGlvbiA9IDI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRpYWw7XG59XG5cbnZhciBtYXBTdGF0dXNPZkRhdGUgPSBmdW5jdGlvbiBtYXBTdGF0dXNPZkRhdGUocmFuZ2UsIHVzZVJhbmdlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZGF0ZVN0cmluZykge1xuICAgIHZhciBsZW5ndGggPSByYW5nZS5sZW5ndGgoKTtcbiAgICB2YXIgc3RhdHVzID0ge1xuICAgICAgaXNBY3RpdmU6IGZhbHNlLFxuICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgaXNTdGFydDogZmFsc2UsXG4gICAgICBpblJhbmdlOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAobGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuXG4gICAgdmFyIGRhdGVUb1N0cmluZyA9IGZ1bmN0aW9uIGRhdGVUb1N0cmluZyhkYXRlKSB7XG4gICAgICByZXR1cm4gVGltZXguZGF0ZUNvbXBvbmVudHMoZGF0ZSkuZGF0ZVN0cmluZztcbiAgICB9O1xuXG4gICAgaWYgKCF1c2VSYW5nZSkge1xuICAgICAgc3RhdHVzLmlzQWN0aXZlID0gcGlwZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gTGlzdC5tYXAoZGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gTGlzdC5tYXAoZGF0YSwgZGF0ZVRvU3RyaW5nKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBMaXN0LmluY2x1ZGVzKGRhdGEsIGRhdGVTdHJpbmcpO1xuICAgICAgfSkocmFuZ2UuZmV0Y2goKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdF8xID0gcmFuZ2UuZmV0Y2goMCk7XG4gICAgICB2YXIgbGFzdCA9IHJhbmdlLmZldGNoKHJhbmdlLmxlbmd0aCgpIC0gMSk7XG4gICAgICB2YXIgZ2V0UmFuZ2UgPSBwaXBlKGZ1bmN0aW9uICgkMSwgJDIpIHtcbiAgICAgICAgcmV0dXJuIFRpbWV4LmRpZmYoJDEsICQyLCBcImRheXNcIiwgdHJ1ZSk7XG4gICAgICB9LCBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICByZXR1cm4gTGlzdC5jcmVhdGUoc2l6ZSArIDEpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBMaXN0Lm1hcChyYW5nZSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IFRpbWV4LmRhdGVDb21wb25lbnRzKGZpcnN0XzEudmFsdWUpO1xuICAgICAgICAgIGNvbXBvbmVudHMuZGF0ZSArPSBpdGVtO1xuICAgICAgICAgIHZhciBkYXRlID0gVGltZXguY3JlYXRlRGF0ZShjb21wb25lbnRzKTtcbiAgICAgICAgICByZXR1cm4gZGF0ZVRvU3RyaW5nKGRhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGRhdGEgPSBnZXRSYW5nZShsYXN0LnZhbHVlLCBmaXJzdF8xLnZhbHVlKTtcbiAgICAgIHN0YXR1cy5pc0FjdGl2ZSA9IExpc3QuaXNUb3AoZGF0YSwgZGF0ZVN0cmluZykgfHwgTGlzdC5pc1RhaWwoZGF0YSwgZGF0ZVN0cmluZyk7XG4gICAgICBzdGF0dXMuaW5SYW5nZSA9IExpc3QuaW5jbHVkZXMoZGF0YSwgZGF0ZVN0cmluZyk7XG4gICAgICBzdGF0dXMuaXNTdGFydCA9IExpc3QuaXNUb3AoZGF0YSwgZGF0ZVN0cmluZyk7XG4gICAgICBzdGF0dXMuaXNFbmQgPSBMaXN0LmlzVGFpbChkYXRhLCBkYXRlU3RyaW5nKTtcblxuICAgICAgaWYgKHN0YXR1cy5pc1N0YXJ0IHx8IHN0YXR1cy5pc0VuZCkge1xuICAgICAgICBzdGF0dXMuaW5SYW5nZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGF0dXM7XG4gIH07XG59O1xuXG52YXIgVXBkYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVXBkYXRlcihjb25maWcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5wdWJzdWIgPSBuZXcgUHViU3ViKGdlblJhbmRvbU51bWJlcigpKTtcblxuICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKGRhdGUsIHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgIF90aGlzLmNvbmZpZy5kYXRlID0gZGF0ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNyZWF0ZURhdGEgPSBwaXBlKGdlblR5cGVQaWNrZXJEYXRhKG1hcFN0YXR1c09mRGF0ZShfdGhpcy5xdWV1ZSwgX3RoaXMuY29uZmlnLnNlbGVjdGlvbiA9PT0gMiksIF90aGlzLmRpc2FibGVzLmZpbmQpKTtcblxuICAgICAgX3RoaXMucHVic3ViLnB1Ymxpc2goVHlwZVBpY2tlckxpc3RlbmVyVHlwZXMudXBkYXRlLCBjcmVhdGVEYXRhKF90aGlzLmNvbmZpZy5zaXplLCBfdGhpcy5jb25maWcuZGF0ZSkpO1xuXG4gICAgICBpZiAoTGlzdC5pc0xpc3Qoc2VsZWN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgX3RoaXMucHVic3ViLnB1Ymxpc2goVHlwZVBpY2tlckxpc3RlbmVyVHlwZXMuc2VsZWN0LCBMaXN0Lm1hcChzZWxlY3RlZFZhbHVlLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucXVldWUgPSBudWxsO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuZGlzYWJsZXMgPSB7XG4gICAgICBmaW5kOiBmdW5jdGlvbiBmaW5kKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5xdWV1ZSA9IG5ldyBRdWV1ZShjb25maWcuc2VsZWN0aW9uLCBjb25maWcudXNlSW52YWxpZEFzU2VsZWN0ZWQpO1xuICB9XG5cbiAgVXBkYXRlci5wcm90b3R5cGUuY2hlY2tRdWV1ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5xdWV1ZTtcbiAgICB2YXIgZGlzYWJsZXMgPSB0aGlzLmRpc2FibGVzO1xuICAgIHZhciBjdXJyZW50ID0gaXRlbS52YWx1ZTtcbiAgICB2YXIgbGFzdCA9IHF1ZXVlLmxhc3QoKTtcbiAgICB2YXIgZmlyc3QgPSBxdWV1ZS5mcm9udCgpO1xuXG4gICAgdmFyIHVucHVzaGFibGUgPSBmdW5jdGlvbiB1bnB1c2hhYmxlKCkge1xuICAgICAgaWYgKGl0ZW0uZGlzYWJsZWQgJiYgY3VycmVudCA8IGxhc3QudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBnZXRTaXplID0gZnVuY3Rpb24gZ2V0U2l6ZShfYSkge1xuICAgICAgICB2YXIgY3VycmVudCA9IF9hWzBdLFxuICAgICAgICAgICAgZmlyc3QgPSBfYVsxXTtcbiAgICAgICAgcmV0dXJuIFtUaW1leC5kaWZmKGN1cnJlbnQsIGZpcnN0LCBcImRheXNcIiwgdHJ1ZSksIGZpcnN0XTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBUaW1leC5kYXRlQ29tcG9uZW50cyhkYXRlKTtcbiAgICAgICAgICBjb21wb25lbnRzLmRhdGUgKz0gaW5kZXg7XG4gICAgICAgICAgcmV0dXJuIFRpbWV4LmNyZWF0ZURhdGUoY29tcG9uZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICB2YXIgZmluZERhdGVzID0gZnVuY3Rpb24gZmluZERhdGVzKF9hKSB7XG4gICAgICAgIHZhciBzaXplID0gX2FbMF0sXG4gICAgICAgICAgICBkYXRlID0gX2FbMV07XG4gICAgICAgIHJldHVybiBMaXN0LmNyZWF0ZShzaXplLCBjcmVhdGUoZGF0ZSkpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGZpbmREaXNhYmxlcyA9IGZ1bmN0aW9uIGZpbmREaXNhYmxlcyhkYXRlcykge1xuICAgICAgICByZXR1cm4gTGlzdC5tYXAoZGF0ZXMsIGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGRpc2FibGVzLmZpbmQoZGF0ZSkgJiYgVGltZXguZGF0ZUNvbXBvbmVudHMoZGF0ZSkudGltZSAhPT0gVGltZXguZGF0ZUNvbXBvbmVudHMoY3VycmVudCkudGltZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZmlsdGVyVHJ1ZSA9IGZ1bmN0aW9uIGZpbHRlclRydWUoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbSA9PT0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgaGFzID0gZnVuY3Rpb24gaGFzKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIExpc3QubGVuZ3RoKGRhdGEpID4gMDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBwaXBlKGdldFNpemUsIGZpbmREYXRlcywgZmluZERpc2FibGVzLCBmaWx0ZXJUcnVlLCBoYXMpKFtpdGVtLnZhbHVlLCBmaXJzdC52YWx1ZV0pO1xuICAgIH07XG5cbiAgICB2YXIgcG9wYWJsZSA9IGZ1bmN0aW9uIHBvcGFibGUoKSB7XG4gICAgICByZXR1cm4gZmlyc3QudmFsdWUgPiBjdXJyZW50O1xuICAgIH07XG5cbiAgICByZXR1cm4gY2hlY2tRdWV1ZShxdWV1ZSwgaXRlbS5kaXNhYmxlZCwgdW5wdXNoYWJsZSwgcG9wYWJsZSk7XG4gIH07XG5cbiAgVXBkYXRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRlLCBjbGVhblF1ZXVlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChjbGVhblF1ZXVlID09PSB2b2lkIDApIHtcbiAgICAgIGNsZWFuUXVldWUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlSXRlbSA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW0odmFsdWUpIHtcbiAgICAgIGlmICghVGltZXguaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3I6IGV4cGVjdGVkIERhdGUgb2JqZWN0LCBidXQgZ290IFwiICsgdmFsdWUgKyBcIiBcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudHMgPSBUaW1leC5kYXRlQ29tcG9uZW50cyh2YWx1ZSk7XG4gICAgICB2YXIgZGF0ZSA9IFRpbWV4LmNyZWF0ZURhdGUoY29tcG9uZW50cyk7XG4gICAgICB2YXIgc2VsZWN0ID0gbmV3IFNlbGVjdGlvbihkYXRlKTtcbiAgICAgIHNlbGVjdC5kaXNhYmxlZCA9IF90aGlzLmRpc2FibGVzLmZpbmQoZGF0ZSk7XG4gICAgICByZXR1cm4gc2VsZWN0O1xuICAgIH07XG5cbiAgICB2YXIgZGF0YSA9IExpc3QuaXNMaXN0KGRhdGUpID8gZGF0ZSA6IFtkYXRlXTtcblxuICAgIGlmIChjbGVhblF1ZXVlKSB7XG4gICAgICB0aGlzLnF1ZXVlLmNsZWFuKCk7XG4gICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEgPSBMaXN0Lm1hcChkYXRhLCBjcmVhdGVJdGVtKTtcblxuICAgIGlmIChMaXN0Lmxlbmd0aCh0aGlzLmRhdGEpIDw9IDApIHtcbiAgICAgIHRoaXMudXBkYXRlKG51bGwsIFtdKTtcbiAgICB9XG5cbiAgICBMaXN0Lmxvb3AodGhpcy5kYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgVGltZXguZGVsYXkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpdGVtLmRpc2FibGVkID0gX3RoaXMuZGlzYWJsZXMuZmluZChpdGVtLnZhbHVlKTtcbiAgICAgIH0sIDApO1xuXG4gICAgICB2YXIgY2FuUHVzaCA9IF90aGlzLmNoZWNrUXVldWUoaXRlbSk7XG5cbiAgICAgIHZhciBjYWxsVXBkYXRlID0gZnVuY3Rpb24gY2FsbFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZShudWxsLCBfdGhpcy5xdWV1ZS5mZXRjaCgpKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChjYW5QdXNoKSB7XG4gICAgICAgIF90aGlzLnF1ZXVlLnB1c2goaXRlbSkoY2FsbFVwZGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFVwZGF0ZXI7XG59KCk7XG5cbnZhciBUeXBlUGlja2VyTGlzdGVuZXJUeXBlcyA9IHtcbiAgdXBkYXRlOiBcInVwZGF0ZVwiLFxuICBzZWxlY3Q6IFwic2VsZWN0XCJcbn07XG5cbmZ1bmN0aW9uIFR5cGVQaWNrZXIob3B0aW9uKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHVwZGF0ZXIgPSBuZXcgVXBkYXRlcihfX2Fzc2lnbih7XG4gICAgc2VsZWN0aW9uOiAxLFxuICAgIGRhdGU6IFRpbWV4LnRvZGF5KCksXG4gICAgdXNlSW52YWxpZEFzU2VsZWN0ZWQ6IGZhbHNlLFxuICAgIHNpemU6IDFcbiAgfSwgZ2V0T3B0aW9ucyhvcHRpb24pKSk7XG5cbiAgdmFyIGFwcGx5RGF0ZXMgPSBmdW5jdGlvbiBhcHBseURhdGVzKGRhdGVzKSB7XG4gICAgdmFyIHNldERhdGVzID0gcGlwZShmdW5jdGlvbiAoZGF0ZXMpIHtcbiAgICAgIHJldHVybiBkYXRlcy5zbGljZSgwLCB1cGRhdGVyLmNvbmZpZy5zZWxlY3Rpb24pO1xuICAgIH0sIGZ1bmN0aW9uIChkYXRlcykge1xuICAgICAgcmV0dXJuIGRhdGVzLmZpbHRlcihUaW1leC5pc0RhdGUpO1xuICAgIH0sIGZ1bmN0aW9uIChkYXRlcykge1xuICAgICAgcmV0dXJuIExpc3QuZGVkdXAoZGF0ZXMsIHNldERhdGVzRGVkdXBlKTtcbiAgICB9LCBmdW5jdGlvbiAoZGF0ZXMpIHtcbiAgICAgIHJldHVybiBMaXN0LmV2ZXJ5KGRhdGVzLCBUaW1leC5pc0RhdGUpID8gZGF0ZXMgOiBbXTtcbiAgICB9LCBmdW5jdGlvbiAoZGF0ZXMpIHtcbiAgICAgIHJldHVybiBkYXRlcy5zb3J0KGZ1bmN0aW9uICh0MSwgdDIpIHtcbiAgICAgICAgcmV0dXJuICt0MSAtICt0MjtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFRpbWV4LmRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZXIucHVzaChzZXREYXRlcyhkYXRlcyksIHRydWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMubGlzdGVuID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgICB1cGRhdGVyLnB1YnN1Yi5zdWJzY3JpYmUoVHlwZVBpY2tlckxpc3RlbmVyVHlwZXMudXBkYXRlLCBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgcmV0dXJuIG5leHQoe1xuICAgICAgICB0eXBlOiBUeXBlUGlja2VyTGlzdGVuZXJUeXBlcy51cGRhdGUsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgIHR5cGVzOiBUeXBlUGlja2VyTGlzdGVuZXJUeXBlc1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdXBkYXRlci5wdWJzdWIuc3Vic2NyaWJlKFR5cGVQaWNrZXJMaXN0ZW5lclR5cGVzLnNlbGVjdCwgZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgIHJldHVybiBuZXh0KHtcbiAgICAgICAgdHlwZTogVHlwZVBpY2tlckxpc3RlbmVyVHlwZXMuc2VsZWN0LFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICB0eXBlczogVHlwZVBpY2tlckxpc3RlbmVyVHlwZXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3QoZGF0ZSkge1xuICAgIGlmIChMaXN0LmlzTGlzdChkYXRlKSkge1xuICAgICAgZGF0ZSA9IGRhdGUucG9wKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlci5wdXNoKGRhdGUpO1xuICB9O1xuXG4gIHRoaXMuYXBwbHkgPSB7XG4gICAgZGF0ZXM6IGFwcGx5RGF0ZXMsXG4gICAgZGlzYWJsZURhdGU6IGZ1bmN0aW9uIGRpc2FibGVEYXRlKGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiB1cGRhdGVyLmRpc2FibGVzLmZpbmQgPSBoYW5kbGVyO1xuICAgIH0sXG4gICAgZGF0ZTogZnVuY3Rpb24gZGF0ZShfZGF0ZSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZXIudXBkYXRlKF9kYXRlLCBudWxsKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZXIudXBkYXRlKG51bGwsIG51bGwpO1xuICAgIH0sXG4gICAgc2VsZWN0OiBzZWxlY3RcbiAgfTtcbiAgVGltZXguZGVsYXkoZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmFwcGx5LnNlbGVjdCh1cGRhdGVyLmNvbmZpZy5kYXRlLCB0cnVlKTtcbiAgfSk7XG59XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gVHlwZVBpY2tlcjtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./dist/typepicker.development.js\n");

/***/ }),

/***/ "./example/index.ts":
/*!**************************!*\
  !*** ./example/index.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar __1 = __webpack_require__(/*! ../ */ \"./index.js\");\n\nvar Timex = {\n  isDate: function isDate(d) {\n    return d instanceof Date;\n  },\n  dateComponents: function dateComponents(input) {\n    var month = input.getMonth();\n    var year = input.getFullYear();\n    var date = input.getDate();\n    var day = input.getDay();\n    var hours = input.getHours();\n    var minutes = input.getMinutes();\n    var seconds = input.getSeconds();\n    var ms = input.getMilliseconds();\n    var dateString = input.toDateString();\n    var isoString = input.toISOString();\n    var time = input.getTime();\n    var timezoneOffset = input.getTimezoneOffset();\n    return {\n      year: year,\n      date: date,\n      month: month,\n      day: day,\n      hours: hours,\n      minutes: minutes,\n      seconds: seconds,\n      ms: ms,\n      milliseconds: ms,\n      dateString: dateString,\n      isoString: isoString,\n      time: time,\n      timezoneOffset: timezoneOffset\n    };\n  },\n  createDate: function createDate(options) {\n    var year = options.year,\n        month = options.month,\n        date = options.date,\n        _a = options.minutes,\n        minutes = _a === void 0 ? 0 : _a,\n        _b = options.hours,\n        hours = _b === void 0 ? 0 : _b,\n        _c = options.seconds,\n        seconds = _c === void 0 ? 0 : _c,\n        _d = options.milliseconds,\n        milliseconds = _d === void 0 ? 0 : _d;\n    return new Date(year, month, date, hours, minutes, seconds, milliseconds);\n  }\n};\nvar DOMHelpers = {\n  select: function select(selector, selector$2) {\n    if (!selector$2) {\n      if (typeof selector !== \"string\") {\n        return selector;\n      } else {\n        return document.querySelector(selector);\n      }\n    }\n\n    var selectAll = function selectAll(who, selector) {\n      var ArrayNodes = who.querySelectorAll(selector);\n\n      if (ArrayNodes.length <= 0) {\n        return null;\n      } else if (ArrayNodes.length === 1) {\n        return ArrayNodes[0];\n      } else {\n        return ArrayNodes;\n      }\n    };\n\n    return selectAll(selector, selector$2);\n  },\n  attr: function attr(el, _attr) {\n    return el.getAttribute(_attr);\n  },\n  \"class\": function _class(index, options) {\n    function classname(options) {\n      var isActive = options.isActive,\n          isStart = options.isStart,\n          isEnd = options.isEnd,\n          isDisabled = options.isDisabled,\n          inRange = options.inRange;\n      var className = \"\";\n\n      if (isActive) {\n        className = \"active\";\n\n        if (isStart) {\n          className = \"active start-date\";\n        } else if (isEnd) {\n          className = \"active end-date\";\n        }\n      }\n\n      if (inRange) {\n        return \"in-range\";\n      }\n\n      if (isDisabled && !isActive) {\n        className = \"disabled\";\n      }\n\n      return className;\n    }\n\n    var names = [\"calendar-cell\"];\n\n    if (index === 0) {\n      names.push(\"is-weekday\");\n    } else if (index === 6) {\n      names.push(\"is-weekend\");\n    }\n\n    names.push(classname(options));\n    return names.join(\" \").trim();\n  }\n};\n\nfunction renderTemplate(data) {\n  var isDef = function isDef(v) {\n    return v !== undefined && v !== null;\n  };\n\n  function createTag(tag, props) {\n    if (!tag) {\n      tag = \"div\";\n    }\n\n    var children = \"\";\n    var attributes = [];\n\n    for (var key in props) {\n      var value = props[key];\n\n      if (isDef(value)) {\n        if (key !== \"children\") {\n          if (key === \"className\") {\n            key = \"class\";\n          }\n\n          attributes.push(key + \"=\\\"\" + value + \"\\\"\");\n        } else {\n          if (value !== false) {\n            if (Array.isArray(value)) {\n              children = value.filter(isDef).join(\"\");\n            } else {\n              children = value;\n            }\n          }\n        }\n      }\n    }\n\n    return \"<\" + tag + \" \" + attributes.join(\"\") + \">\" + children + \"</\" + tag + \">\";\n  }\n\n  var actionNode = function actionNode(type, step) {\n    var className = [\"calendar-action\", type];\n    return createTag(\"div\", {\n      className: className.join(\" \"),\n      \"data-step\": step\n    });\n  };\n\n  function dateNodes(data) {\n    var props = {\n      className: DOMHelpers[\"class\"](data.day, data.status),\n      children: []\n    };\n    props.children.push(createTag(\"div\", {\n      className: \"date\",\n      children: data.label\n    }));\n    props[\"data-date\"] = data.value;\n    props[\"data-disabled\"] = data.disabled;\n    return createTag(\"div\", props);\n  }\n\n  var calendars = data.map(function (item) {\n    var calendarViewData = [createTag(\"div\", {\n      className: \"calendar-head\",\n      children: item.heading\n    }), createTag(\"div\", {\n      className: \"calendar-day\",\n      children: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"].map(function (day) {\n        return createTag(\"div\", {\n          className: \"calendar-cell\",\n          children: day\n        });\n      })\n    }), createTag(\"div\", {\n      className: \"calendar-body\",\n      children: item.dates.map(dateNodes)\n    })];\n    return createTag(\"div\", {\n      className: \"calendar-item\",\n      children: calendarViewData\n    });\n  });\n  return [actionNode(\"prev\", -1), actionNode(\"next\", 1)].concat(calendars).join(\"\");\n}\n\nvar TypePickerExample = function () {\n  function TypePickerExample(element, options) {\n    this.date = new Date();\n    this.apply = null;\n    this.init(element, options);\n  }\n\n  TypePickerExample.prototype.init = function (element, config) {\n    var _this = this;\n\n    this.element = DOMHelpers.select(element);\n    var picker = new __1[\"default\"](config);\n    picker.listen(this.render.bind(this));\n    this.apply = __assign({}, picker.apply, {\n      date: function date(_date) {\n        _this.date = _date;\n        picker.apply.date(_date);\n      }\n    });\n    this.apply.date(new Date());\n  };\n\n  TypePickerExample.prototype.render = function (options) {\n    var _this = this;\n\n    var data = options.payload;\n\n    if (options.type !== options.types.update) {\n      data = data.map(function (item) {\n        return item.toLocaleDateString();\n      });\n\n      this._onSelect(data);\n\n      return;\n    }\n\n    this.element.innerHTML = renderTemplate(data.map(function (item) {\n      return {\n        heading: item.year + \"\\u5E74 \" + (item.month + 1) + \"\\u6708\",\n        dates: item.dates.map(function (item) {\n          item.value = item.date.toLocaleDateString();\n          item.label = item.date.getDate().toString();\n          item.day = item.date.getDay().toString();\n\n          if (item.invalid) {\n            for (var key in item.status) {\n              item.status[key] = false;\n            }\n          }\n\n          item.status.isDisabled = item.disabled || item.invalid;\n          return item;\n        })\n      };\n    }));\n    var actions = DOMHelpers.select(this.element, \".calendar-action\");\n\n    if (actions) {\n      var _loop_1 = function _loop_1(actioner) {\n        var stepper = function stepper() {\n          var _step = DOMHelpers.attr(actioner, \"data-step\");\n\n          var step = parseInt(_step, 10);\n          var components = Timex.dateComponents(_this.date);\n          components.month += step;\n\n          _this.apply.date(Timex.createDate(components));\n        };\n\n        actioner.addEventListener(\"click\", function () {\n          return stepper();\n        });\n      };\n\n      for (var _i = 0, actions_1 = actions; _i < actions_1.length; _i++) {\n        var actioner = actions_1[_i];\n\n        _loop_1(actioner);\n      }\n    }\n\n    var cells = DOMHelpers.select(this.element, \".calendar-cell\");\n\n    var _loop_2 = function _loop_2(node) {\n      node.addEventListener(\"click\", function () {\n        var value = DOMHelpers.attr(node, \"data-date\");\n\n        if (!value) {\n          return;\n        }\n\n        _this.apply.select(new Date(value));\n      });\n    };\n\n    for (var _a = 0, cells_1 = cells; _a < cells_1.length; _a++) {\n      var node = cells_1[_a];\n\n      _loop_2(node);\n    }\n  };\n\n  TypePickerExample.prototype.onSelect = function (next) {\n    this._onSelect = next;\n  };\n\n  return TypePickerExample;\n}();\n\nvar picker = new TypePickerExample(\"#picker\", {\n  selection: 2,\n  size: 9\n});\npicker.apply.disableDate(function (_) {\n  var day = _.getDay();\n\n  return day === 4 || day === 2;\n});\npicker.apply.date(new Date(2019, 10, 1));\nvar datesToSet = [new Date(\"2019/07/31\"), new Date(\"2019/08/02\")];\npicker.apply.dates(datesToSet);\npicker.onSelect(function (value) {\n  console.log(\"onselect\", value);\n  document.getElementById(\"value\").innerText = value.join(\",\");\n});\nwindow[\"pickerApp\"] = picker;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlL2luZGV4LnRzP2FlZjciXSwibmFtZXMiOlsiX19hc3NpZ24iLCJPYmplY3QiLCJhc3NpZ24iLCJ0IiwicyIsImkiLCJuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfXzEiLCJyZXF1aXJlIiwiVGltZXgiLCJpc0RhdGUiLCJkIiwiRGF0ZSIsImRhdGVDb21wb25lbnRzIiwiaW5wdXQiLCJtb250aCIsImdldE1vbnRoIiwieWVhciIsImdldEZ1bGxZZWFyIiwiZGF0ZSIsImdldERhdGUiLCJkYXkiLCJnZXREYXkiLCJob3VycyIsImdldEhvdXJzIiwibWludXRlcyIsImdldE1pbnV0ZXMiLCJzZWNvbmRzIiwiZ2V0U2Vjb25kcyIsIm1zIiwiZ2V0TWlsbGlzZWNvbmRzIiwiZGF0ZVN0cmluZyIsInRvRGF0ZVN0cmluZyIsImlzb1N0cmluZyIsInRvSVNPU3RyaW5nIiwidGltZSIsImdldFRpbWUiLCJ0aW1lem9uZU9mZnNldCIsImdldFRpbWV6b25lT2Zmc2V0IiwibWlsbGlzZWNvbmRzIiwiY3JlYXRlRGF0ZSIsIm9wdGlvbnMiLCJfYSIsIl9iIiwiX2MiLCJfZCIsIkRPTUhlbHBlcnMiLCJzZWxlY3QiLCJzZWxlY3RvciIsInNlbGVjdG9yJDIiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJzZWxlY3RBbGwiLCJ3aG8iLCJBcnJheU5vZGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImF0dHIiLCJlbCIsImdldEF0dHJpYnV0ZSIsImluZGV4IiwiY2xhc3NuYW1lIiwiaXNBY3RpdmUiLCJpc1N0YXJ0IiwiaXNFbmQiLCJpc0Rpc2FibGVkIiwiaW5SYW5nZSIsImNsYXNzTmFtZSIsIm5hbWVzIiwicHVzaCIsImpvaW4iLCJ0cmltIiwicmVuZGVyVGVtcGxhdGUiLCJkYXRhIiwiaXNEZWYiLCJ2IiwidW5kZWZpbmVkIiwiY3JlYXRlVGFnIiwidGFnIiwicHJvcHMiLCJjaGlsZHJlbiIsImF0dHJpYnV0ZXMiLCJrZXkiLCJBcnJheSIsImlzQXJyYXkiLCJmaWx0ZXIiLCJhY3Rpb25Ob2RlIiwidHlwZSIsInN0ZXAiLCJkYXRlTm9kZXMiLCJzdGF0dXMiLCJsYWJlbCIsImRpc2FibGVkIiwiY2FsZW5kYXJzIiwibWFwIiwiaXRlbSIsImNhbGVuZGFyVmlld0RhdGEiLCJoZWFkaW5nIiwiZGF0ZXMiLCJjb25jYXQiLCJUeXBlUGlja2VyRXhhbXBsZSIsImVsZW1lbnQiLCJpbml0IiwiY29uZmlnIiwiX3RoaXMiLCJwaWNrZXIiLCJsaXN0ZW4iLCJyZW5kZXIiLCJiaW5kIiwicGF5bG9hZCIsInR5cGVzIiwidXBkYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwiX29uU2VsZWN0IiwiaW5uZXJIVE1MIiwidG9TdHJpbmciLCJpbnZhbGlkIiwiYWN0aW9ucyIsIl9sb29wXzEiLCJhY3Rpb25lciIsInN0ZXBwZXIiLCJfc3RlcCIsInBhcnNlSW50IiwiY29tcG9uZW50cyIsImFkZEV2ZW50TGlzdGVuZXIiLCJfaSIsImFjdGlvbnNfMSIsImNlbGxzIiwiX2xvb3BfMiIsIm5vZGUiLCJjZWxsc18xIiwib25TZWxlY3QiLCJuZXh0Iiwic2VsZWN0aW9uIiwic2l6ZSIsImRpc2FibGVEYXRlIiwiXyIsImRhdGVzVG9TZXQiLCJjb25zb2xlIiwibG9nIiwiZ2V0RWxlbWVudEJ5SWQiLCJpbm5lclRleHQiLCJ3aW5kb3ciXSwibWFwcGluZ3MiOiJBQUFhOztBQUNiLElBQUlBLFFBQVEsR0FBSSxRQUFRLEtBQUtBLFFBQWQsSUFBMkIsWUFBWTtBQUNsREEsVUFBUSxHQUFHQyxNQUFNLENBQUNDLE1BQVAsSUFBaUIsVUFBU0MsQ0FBVCxFQUFZO0FBQ3BDLFNBQUssSUFBSUMsQ0FBSixFQUFPQyxDQUFDLEdBQUcsQ0FBWCxFQUFjQyxDQUFDLEdBQUdDLFNBQVMsQ0FBQ0MsTUFBakMsRUFBeUNILENBQUMsR0FBR0MsQ0FBN0MsRUFBZ0RELENBQUMsRUFBakQsRUFBcUQ7QUFDakRELE9BQUMsR0FBR0csU0FBUyxDQUFDRixDQUFELENBQWI7O0FBQ0EsV0FBSyxJQUFJSSxDQUFULElBQWNMLENBQWQ7QUFBaUIsWUFBSUgsTUFBTSxDQUFDUyxTQUFQLENBQWlCQyxjQUFqQixDQUFnQ0MsSUFBaEMsQ0FBcUNSLENBQXJDLEVBQXdDSyxDQUF4QyxDQUFKLEVBQ2JOLENBQUMsQ0FBQ00sQ0FBRCxDQUFELEdBQU9MLENBQUMsQ0FBQ0ssQ0FBRCxDQUFSO0FBREo7QUFFSDs7QUFDRCxXQUFPTixDQUFQO0FBQ0gsR0FQRDs7QUFRQSxTQUFPSCxRQUFRLENBQUNhLEtBQVQsQ0FBZSxJQUFmLEVBQXFCTixTQUFyQixDQUFQO0FBQ0gsQ0FWRDs7QUFXQU4sTUFBTSxDQUFDYSxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFQyxPQUFLLEVBQUU7QUFBVCxDQUE3Qzs7QUFDQSxJQUFJQyxHQUFHLEdBQUdDLG1CQUFPLENBQUMsdUJBQUQsQ0FBakI7O0FBQ0EsSUFBSUMsS0FBSyxHQUFHO0FBQ1JDLFFBQU0sRUFBRSxnQkFBVUMsQ0FBVixFQUFhO0FBQUUsV0FBT0EsQ0FBQyxZQUFZQyxJQUFwQjtBQUEyQixHQUQxQztBQUVSQyxnQkFBYyxFQUFFLHdCQUFVQyxLQUFWLEVBQWlCO0FBQzdCLFFBQUlDLEtBQUssR0FBR0QsS0FBSyxDQUFDRSxRQUFOLEVBQVo7QUFDQSxRQUFJQyxJQUFJLEdBQUdILEtBQUssQ0FBQ0ksV0FBTixFQUFYO0FBQ0EsUUFBSUMsSUFBSSxHQUFHTCxLQUFLLENBQUNNLE9BQU4sRUFBWDtBQUNBLFFBQUlDLEdBQUcsR0FBR1AsS0FBSyxDQUFDUSxNQUFOLEVBQVY7QUFDQSxRQUFJQyxLQUFLLEdBQUdULEtBQUssQ0FBQ1UsUUFBTixFQUFaO0FBQ0EsUUFBSUMsT0FBTyxHQUFHWCxLQUFLLENBQUNZLFVBQU4sRUFBZDtBQUNBLFFBQUlDLE9BQU8sR0FBR2IsS0FBSyxDQUFDYyxVQUFOLEVBQWQ7QUFDQSxRQUFJQyxFQUFFLEdBQUdmLEtBQUssQ0FBQ2dCLGVBQU4sRUFBVDtBQUNBLFFBQUlDLFVBQVUsR0FBR2pCLEtBQUssQ0FBQ2tCLFlBQU4sRUFBakI7QUFDQSxRQUFJQyxTQUFTLEdBQUduQixLQUFLLENBQUNvQixXQUFOLEVBQWhCO0FBQ0EsUUFBSUMsSUFBSSxHQUFHckIsS0FBSyxDQUFDc0IsT0FBTixFQUFYO0FBQ0EsUUFBSUMsY0FBYyxHQUFHdkIsS0FBSyxDQUFDd0IsaUJBQU4sRUFBckI7QUFDQSxXQUFPO0FBQ0hyQixVQUFJLEVBQUVBLElBREg7QUFFSEUsVUFBSSxFQUFFQSxJQUZIO0FBR0hKLFdBQUssRUFBRUEsS0FISjtBQUlITSxTQUFHLEVBQUVBLEdBSkY7QUFLSEUsV0FBSyxFQUFFQSxLQUxKO0FBTUhFLGFBQU8sRUFBRUEsT0FOTjtBQU9IRSxhQUFPLEVBQUVBLE9BUE47QUFRSEUsUUFBRSxFQUFFQSxFQVJEO0FBU0hVLGtCQUFZLEVBQUVWLEVBVFg7QUFVSEUsZ0JBQVUsRUFBRUEsVUFWVDtBQVdIRSxlQUFTLEVBQUVBLFNBWFI7QUFZSEUsVUFBSSxFQUFFQSxJQVpIO0FBYUhFLG9CQUFjLEVBQUVBO0FBYmIsS0FBUDtBQWVILEdBOUJPO0FBK0JSRyxZQUFVLEVBQUUsb0JBQVVDLE9BQVYsRUFBbUI7QUFDM0IsUUFBSXhCLElBQUksR0FBR3dCLE9BQU8sQ0FBQ3hCLElBQW5CO0FBQUEsUUFBeUJGLEtBQUssR0FBRzBCLE9BQU8sQ0FBQzFCLEtBQXpDO0FBQUEsUUFBZ0RJLElBQUksR0FBR3NCLE9BQU8sQ0FBQ3RCLElBQS9EO0FBQUEsUUFBcUV1QixFQUFFLEdBQUdELE9BQU8sQ0FBQ2hCLE9BQWxGO0FBQUEsUUFBMkZBLE9BQU8sR0FBR2lCLEVBQUUsS0FBSyxLQUFLLENBQVosR0FBZ0IsQ0FBaEIsR0FBb0JBLEVBQXpIO0FBQUEsUUFBNkhDLEVBQUUsR0FBR0YsT0FBTyxDQUFDbEIsS0FBMUk7QUFBQSxRQUFpSkEsS0FBSyxHQUFHb0IsRUFBRSxLQUFLLEtBQUssQ0FBWixHQUFnQixDQUFoQixHQUFvQkEsRUFBN0s7QUFBQSxRQUFpTEMsRUFBRSxHQUFHSCxPQUFPLENBQUNkLE9BQTlMO0FBQUEsUUFBdU1BLE9BQU8sR0FBR2lCLEVBQUUsS0FBSyxLQUFLLENBQVosR0FBZ0IsQ0FBaEIsR0FBb0JBLEVBQXJPO0FBQUEsUUFBeU9DLEVBQUUsR0FBR0osT0FBTyxDQUFDRixZQUF0UDtBQUFBLFFBQW9RQSxZQUFZLEdBQUdNLEVBQUUsS0FBSyxLQUFLLENBQVosR0FBZ0IsQ0FBaEIsR0FBb0JBLEVBQXZTO0FBQ0EsV0FBTyxJQUFJakMsSUFBSixDQUFTSyxJQUFULEVBQWVGLEtBQWYsRUFBc0JJLElBQXRCLEVBQTRCSSxLQUE1QixFQUFtQ0UsT0FBbkMsRUFBNENFLE9BQTVDLEVBQXFEWSxZQUFyRCxDQUFQO0FBQ0g7QUFsQ08sQ0FBWjtBQW9DQSxJQUFJTyxVQUFVLEdBQUc7QUFDYkMsUUFBTSxFQUFFLGdCQUFVQyxRQUFWLEVBQW9CQyxVQUFwQixFQUFnQztBQUNwQyxRQUFJLENBQUNBLFVBQUwsRUFBaUI7QUFDYixVQUFJLE9BQU9ELFFBQVAsS0FBb0IsUUFBeEIsRUFBa0M7QUFDOUIsZUFBT0EsUUFBUDtBQUNILE9BRkQsTUFHSztBQUNELGVBQU9FLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QkgsUUFBdkIsQ0FBUDtBQUNIO0FBQ0o7O0FBQ0QsUUFBSUksU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBVUMsR0FBVixFQUFlTCxRQUFmLEVBQXlCO0FBQ3JDLFVBQUlNLFVBQVUsR0FBR0QsR0FBRyxDQUFDRSxnQkFBSixDQUFxQlAsUUFBckIsQ0FBakI7O0FBQ0EsVUFBSU0sVUFBVSxDQUFDeEQsTUFBWCxJQUFxQixDQUF6QixFQUE0QjtBQUN4QixlQUFPLElBQVA7QUFDSCxPQUZELE1BR0ssSUFBSXdELFVBQVUsQ0FBQ3hELE1BQVgsS0FBc0IsQ0FBMUIsRUFBNkI7QUFDOUIsZUFBT3dELFVBQVUsQ0FBQyxDQUFELENBQWpCO0FBQ0gsT0FGSSxNQUdBO0FBQ0QsZUFBT0EsVUFBUDtBQUNIO0FBQ0osS0FYRDs7QUFZQSxXQUFPRixTQUFTLENBQUNKLFFBQUQsRUFBV0MsVUFBWCxDQUFoQjtBQUNILEdBdkJZO0FBd0JiTyxNQUFJLEVBQUUsY0FBVUMsRUFBVixFQUFjRCxLQUFkLEVBQW9CO0FBQUUsV0FBT0MsRUFBRSxDQUFDQyxZQUFILENBQWdCRixLQUFoQixDQUFQO0FBQStCLEdBeEI5QztBQXlCYixXQUFPLGdCQUFVRyxLQUFWLEVBQWlCbEIsT0FBakIsRUFBMEI7QUFDN0IsYUFBU21CLFNBQVQsQ0FBbUJuQixPQUFuQixFQUE0QjtBQUN4QixVQUFJb0IsUUFBUSxHQUFHcEIsT0FBTyxDQUFDb0IsUUFBdkI7QUFBQSxVQUFpQ0MsT0FBTyxHQUFHckIsT0FBTyxDQUFDcUIsT0FBbkQ7QUFBQSxVQUE0REMsS0FBSyxHQUFHdEIsT0FBTyxDQUFDc0IsS0FBNUU7QUFBQSxVQUFtRkMsVUFBVSxHQUFHdkIsT0FBTyxDQUFDdUIsVUFBeEc7QUFBQSxVQUFvSEMsT0FBTyxHQUFHeEIsT0FBTyxDQUFDd0IsT0FBdEk7QUFDQSxVQUFJQyxTQUFTLEdBQUcsRUFBaEI7O0FBQ0EsVUFBSUwsUUFBSixFQUFjO0FBQ1ZLLGlCQUFTLEdBQUcsUUFBWjs7QUFDQSxZQUFJSixPQUFKLEVBQWE7QUFDVEksbUJBQVMsR0FBRyxtQkFBWjtBQUNILFNBRkQsTUFHSyxJQUFJSCxLQUFKLEVBQVc7QUFDWkcsbUJBQVMsR0FBRyxpQkFBWjtBQUNIO0FBQ0o7O0FBQ0QsVUFBSUQsT0FBSixFQUFhO0FBQ1QsZUFBTyxVQUFQO0FBQ0g7O0FBQ0QsVUFBSUQsVUFBVSxJQUFJLENBQUNILFFBQW5CLEVBQTZCO0FBQ3pCSyxpQkFBUyxHQUFHLFVBQVo7QUFDSDs7QUFDRCxhQUFPQSxTQUFQO0FBQ0g7O0FBQ0QsUUFBSUMsS0FBSyxHQUFHLENBQUMsZUFBRCxDQUFaOztBQUNBLFFBQUlSLEtBQUssS0FBSyxDQUFkLEVBQWlCO0FBQ2JRLFdBQUssQ0FBQ0MsSUFBTixDQUFXLFlBQVg7QUFDSCxLQUZELE1BR0ssSUFBSVQsS0FBSyxLQUFLLENBQWQsRUFBaUI7QUFDbEJRLFdBQUssQ0FBQ0MsSUFBTixDQUFXLFlBQVg7QUFDSDs7QUFDREQsU0FBSyxDQUFDQyxJQUFOLENBQVdSLFNBQVMsQ0FBQ25CLE9BQUQsQ0FBcEI7QUFDQSxXQUFPMEIsS0FBSyxDQUFDRSxJQUFOLENBQVcsR0FBWCxFQUFnQkMsSUFBaEIsRUFBUDtBQUNIO0FBdkRZLENBQWpCOztBQXlEQSxTQUFTQyxjQUFULENBQXdCQyxJQUF4QixFQUE4QjtBQUMxQixNQUFJQyxLQUFLLEdBQUcsU0FBUkEsS0FBUSxDQUFVQyxDQUFWLEVBQWE7QUFBRSxXQUFPQSxDQUFDLEtBQUtDLFNBQU4sSUFBbUJELENBQUMsS0FBSyxJQUFoQztBQUF1QyxHQUFsRTs7QUFDQSxXQUFTRSxTQUFULENBQW1CQyxHQUFuQixFQUF3QkMsS0FBeEIsRUFBK0I7QUFDM0IsUUFBSSxDQUFDRCxHQUFMLEVBQVU7QUFDTkEsU0FBRyxHQUFHLEtBQU47QUFDSDs7QUFDRCxRQUFJRSxRQUFRLEdBQUcsRUFBZjtBQUNBLFFBQUlDLFVBQVUsR0FBRyxFQUFqQjs7QUFDQSxTQUFLLElBQUlDLEdBQVQsSUFBZ0JILEtBQWhCLEVBQXVCO0FBQ25CLFVBQUl4RSxLQUFLLEdBQUd3RSxLQUFLLENBQUNHLEdBQUQsQ0FBakI7O0FBQ0EsVUFBSVIsS0FBSyxDQUFDbkUsS0FBRCxDQUFULEVBQWtCO0FBQ2QsWUFBSTJFLEdBQUcsS0FBSyxVQUFaLEVBQXdCO0FBQ3BCLGNBQUlBLEdBQUcsS0FBSyxXQUFaLEVBQXlCO0FBQ3JCQSxlQUFHLEdBQUcsT0FBTjtBQUNIOztBQUNERCxvQkFBVSxDQUFDWixJQUFYLENBQWdCYSxHQUFHLEdBQUcsS0FBTixHQUFjM0UsS0FBZCxHQUFzQixJQUF0QztBQUNILFNBTEQsTUFNSztBQUNELGNBQUlBLEtBQUssS0FBSyxLQUFkLEVBQXFCO0FBQ2pCLGdCQUFJNEUsS0FBSyxDQUFDQyxPQUFOLENBQWM3RSxLQUFkLENBQUosRUFBMEI7QUFDdEJ5RSxzQkFBUSxHQUFHekUsS0FBSyxDQUFDOEUsTUFBTixDQUFhWCxLQUFiLEVBQW9CSixJQUFwQixDQUF5QixFQUF6QixDQUFYO0FBQ0gsYUFGRCxNQUdLO0FBQ0RVLHNCQUFRLEdBQUd6RSxLQUFYO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSjs7QUFDRCxXQUFPLE1BQU11RSxHQUFOLEdBQVksR0FBWixHQUFrQkcsVUFBVSxDQUFDWCxJQUFYLENBQWdCLEVBQWhCLENBQWxCLEdBQXdDLEdBQXhDLEdBQThDVSxRQUE5QyxHQUF5RCxJQUF6RCxHQUFnRUYsR0FBaEUsR0FBc0UsR0FBN0U7QUFDSDs7QUFDRCxNQUFJUSxVQUFVLEdBQUcsU0FBYkEsVUFBYSxDQUFVQyxJQUFWLEVBQWdCQyxJQUFoQixFQUFzQjtBQUNuQyxRQUFJckIsU0FBUyxHQUFHLENBQUMsaUJBQUQsRUFBb0JvQixJQUFwQixDQUFoQjtBQUNBLFdBQU9WLFNBQVMsQ0FBQyxLQUFELEVBQVE7QUFDcEJWLGVBQVMsRUFBRUEsU0FBUyxDQUFDRyxJQUFWLENBQWUsR0FBZixDQURTO0FBRXBCLG1CQUFha0I7QUFGTyxLQUFSLENBQWhCO0FBSUgsR0FORDs7QUFPQSxXQUFTQyxTQUFULENBQW1CaEIsSUFBbkIsRUFBeUI7QUFDckIsUUFBSU0sS0FBSyxHQUFHO0FBQ1JaLGVBQVMsRUFBRXBCLFVBQVUsU0FBVixDQUFpQjBCLElBQUksQ0FBQ25ELEdBQXRCLEVBQTJCbUQsSUFBSSxDQUFDaUIsTUFBaEMsQ0FESDtBQUVSVixjQUFRLEVBQUU7QUFGRixLQUFaO0FBSUFELFNBQUssQ0FBQ0MsUUFBTixDQUFlWCxJQUFmLENBQW9CUSxTQUFTLENBQUMsS0FBRCxFQUFRO0FBQ2pDVixlQUFTLEVBQUUsTUFEc0I7QUFFakNhLGNBQVEsRUFBRVAsSUFBSSxDQUFDa0I7QUFGa0IsS0FBUixDQUE3QjtBQUlBWixTQUFLLENBQUMsV0FBRCxDQUFMLEdBQXFCTixJQUFJLENBQUNsRSxLQUExQjtBQUNBd0UsU0FBSyxDQUFDLGVBQUQsQ0FBTCxHQUF5Qk4sSUFBSSxDQUFDbUIsUUFBOUI7QUFDQSxXQUFPZixTQUFTLENBQUMsS0FBRCxFQUFRRSxLQUFSLENBQWhCO0FBQ0g7O0FBQ0QsTUFBSWMsU0FBUyxHQUFHcEIsSUFBSSxDQUFDcUIsR0FBTCxDQUFTLFVBQVVDLElBQVYsRUFBZ0I7QUFDckMsUUFBSUMsZ0JBQWdCLEdBQUcsQ0FDbkJuQixTQUFTLENBQUMsS0FBRCxFQUFRO0FBQ2JWLGVBQVMsRUFBRSxlQURFO0FBRWJhLGNBQVEsRUFBRWUsSUFBSSxDQUFDRTtBQUZGLEtBQVIsQ0FEVSxFQUtuQnBCLFNBQVMsQ0FBQyxLQUFELEVBQVE7QUFDYlYsZUFBUyxFQUFFLGNBREU7QUFFYmEsY0FBUSxFQUFFLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCLEVBQXFCLEdBQXJCLEVBQTBCLEdBQTFCLEVBQStCLEdBQS9CLEVBQW9DYyxHQUFwQyxDQUF3QyxVQUFVeEUsR0FBVixFQUFlO0FBQzdELGVBQU91RCxTQUFTLENBQUMsS0FBRCxFQUFRO0FBQ3BCVixtQkFBUyxFQUFFLGVBRFM7QUFFcEJhLGtCQUFRLEVBQUUxRDtBQUZVLFNBQVIsQ0FBaEI7QUFJSCxPQUxTO0FBRkcsS0FBUixDQUxVLEVBY25CdUQsU0FBUyxDQUFDLEtBQUQsRUFBUTtBQUNiVixlQUFTLEVBQUUsZUFERTtBQUViYSxjQUFRLEVBQUVlLElBQUksQ0FBQ0csS0FBTCxDQUFXSixHQUFYLENBQWVMLFNBQWY7QUFGRyxLQUFSLENBZFUsQ0FBdkI7QUFtQkEsV0FBT1osU0FBUyxDQUFDLEtBQUQsRUFBUTtBQUNwQlYsZUFBUyxFQUFFLGVBRFM7QUFFcEJhLGNBQVEsRUFBRWdCO0FBRlUsS0FBUixDQUFoQjtBQUlILEdBeEJlLENBQWhCO0FBeUJBLFNBQU8sQ0FBQ1YsVUFBVSxDQUFDLE1BQUQsRUFBUyxDQUFDLENBQVYsQ0FBWCxFQUF5QkEsVUFBVSxDQUFDLE1BQUQsRUFBUyxDQUFULENBQW5DLEVBQWdEYSxNQUFoRCxDQUF1RE4sU0FBdkQsRUFBa0V2QixJQUFsRSxDQUF1RSxFQUF2RSxDQUFQO0FBQ0g7O0FBQ0QsSUFBSThCLGlCQUFpQixHQUFJLFlBQVk7QUFDakMsV0FBU0EsaUJBQVQsQ0FBMkJDLE9BQTNCLEVBQW9DM0QsT0FBcEMsRUFBNkM7QUFDekMsU0FBS3RCLElBQUwsR0FBWSxJQUFJUCxJQUFKLEVBQVo7QUFDQSxTQUFLVCxLQUFMLEdBQWEsSUFBYjtBQUNBLFNBQUtrRyxJQUFMLENBQVVELE9BQVYsRUFBbUIzRCxPQUFuQjtBQUNIOztBQUNEMEQsbUJBQWlCLENBQUNuRyxTQUFsQixDQUE0QnFHLElBQTVCLEdBQW1DLFVBQVVELE9BQVYsRUFBbUJFLE1BQW5CLEVBQTJCO0FBQzFELFFBQUlDLEtBQUssR0FBRyxJQUFaOztBQUNBLFNBQUtILE9BQUwsR0FBZXRELFVBQVUsQ0FBQ0MsTUFBWCxDQUFrQnFELE9BQWxCLENBQWY7QUFDQSxRQUFJSSxNQUFNLEdBQUcsSUFBSWpHLEdBQUcsV0FBUCxDQUFnQitGLE1BQWhCLENBQWI7QUFDQUUsVUFBTSxDQUFDQyxNQUFQLENBQWMsS0FBS0MsTUFBTCxDQUFZQyxJQUFaLENBQWlCLElBQWpCLENBQWQ7QUFDQSxTQUFLeEcsS0FBTCxHQUFhYixRQUFRLENBQUMsRUFBRCxFQUFLa0gsTUFBTSxDQUFDckcsS0FBWixFQUFtQjtBQUFFZ0IsVUFBSSxFQUFFLGNBQVVBLEtBQVYsRUFBZ0I7QUFDeERvRixhQUFLLENBQUNwRixJQUFOLEdBQWFBLEtBQWI7QUFDQXFGLGNBQU0sQ0FBQ3JHLEtBQVAsQ0FBYWdCLElBQWIsQ0FBa0JBLEtBQWxCO0FBQ0g7QUFIbUMsS0FBbkIsQ0FBckI7QUFJQSxTQUFLaEIsS0FBTCxDQUFXZ0IsSUFBWCxDQUFnQixJQUFJUCxJQUFKLEVBQWhCO0FBQ0gsR0FWRDs7QUFXQXVGLG1CQUFpQixDQUFDbkcsU0FBbEIsQ0FBNEIwRyxNQUE1QixHQUFxQyxVQUFVakUsT0FBVixFQUFtQjtBQUNwRCxRQUFJOEQsS0FBSyxHQUFHLElBQVo7O0FBQ0EsUUFBSS9CLElBQUksR0FBRy9CLE9BQU8sQ0FBQ21FLE9BQW5COztBQUNBLFFBQUluRSxPQUFPLENBQUM2QyxJQUFSLEtBQWlCN0MsT0FBTyxDQUFDb0UsS0FBUixDQUFjQyxNQUFuQyxFQUEyQztBQUN2Q3RDLFVBQUksR0FBR0EsSUFBSSxDQUFDcUIsR0FBTCxDQUFTLFVBQVVDLElBQVYsRUFBZ0I7QUFBRSxlQUFPQSxJQUFJLENBQUNpQixrQkFBTCxFQUFQO0FBQW1DLE9BQTlELENBQVA7O0FBQ0EsV0FBS0MsU0FBTCxDQUFleEMsSUFBZjs7QUFDQTtBQUNIOztBQUNELFNBQUs0QixPQUFMLENBQWFhLFNBQWIsR0FBeUIxQyxjQUFjLENBQUNDLElBQUksQ0FBQ3FCLEdBQUwsQ0FBUyxVQUFVQyxJQUFWLEVBQWdCO0FBQzdELGFBQU87QUFDSEUsZUFBTyxFQUFFRixJQUFJLENBQUM3RSxJQUFMLEdBQVksU0FBWixJQUF5QjZFLElBQUksQ0FBQy9FLEtBQUwsR0FBYSxDQUF0QyxJQUEyQyxRQURqRDtBQUVIa0YsYUFBSyxFQUFFSCxJQUFJLENBQUNHLEtBQUwsQ0FBV0osR0FBWCxDQUFlLFVBQVVDLElBQVYsRUFBZ0I7QUFDbENBLGNBQUksQ0FBQ3hGLEtBQUwsR0FBYXdGLElBQUksQ0FBQzNFLElBQUwsQ0FBVTRGLGtCQUFWLEVBQWI7QUFDQWpCLGNBQUksQ0FBQ0osS0FBTCxHQUFhSSxJQUFJLENBQUMzRSxJQUFMLENBQVVDLE9BQVYsR0FBb0I4RixRQUFwQixFQUFiO0FBQ0FwQixjQUFJLENBQUN6RSxHQUFMLEdBQVd5RSxJQUFJLENBQUMzRSxJQUFMLENBQVVHLE1BQVYsR0FBbUI0RixRQUFuQixFQUFYOztBQUNBLGNBQUlwQixJQUFJLENBQUNxQixPQUFULEVBQWtCO0FBQ2QsaUJBQUssSUFBSWxDLEdBQVQsSUFBZ0JhLElBQUksQ0FBQ0wsTUFBckIsRUFBNkI7QUFDekJLLGtCQUFJLENBQUNMLE1BQUwsQ0FBWVIsR0FBWixJQUFtQixLQUFuQjtBQUNIO0FBQ0o7O0FBQ0RhLGNBQUksQ0FBQ0wsTUFBTCxDQUFZekIsVUFBWixHQUF5QjhCLElBQUksQ0FBQ0gsUUFBTCxJQUFpQkcsSUFBSSxDQUFDcUIsT0FBL0M7QUFDQSxpQkFBT3JCLElBQVA7QUFDSCxTQVhNO0FBRkosT0FBUDtBQWVILEtBaEJ1QyxDQUFELENBQXZDO0FBaUJBLFFBQUlzQixPQUFPLEdBQUd0RSxVQUFVLENBQUNDLE1BQVgsQ0FBa0IsS0FBS3FELE9BQXZCLEVBQWdDLGtCQUFoQyxDQUFkOztBQUNBLFFBQUlnQixPQUFKLEVBQWE7QUFDVCxVQUFJQyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFVQyxRQUFWLEVBQW9CO0FBQzlCLFlBQUlDLE9BQU8sR0FBRyxTQUFWQSxPQUFVLEdBQVk7QUFDdEIsY0FBSUMsS0FBSyxHQUFHMUUsVUFBVSxDQUFDVSxJQUFYLENBQWdCOEQsUUFBaEIsRUFBMEIsV0FBMUIsQ0FBWjs7QUFDQSxjQUFJL0IsSUFBSSxHQUFHa0MsUUFBUSxDQUFDRCxLQUFELEVBQVEsRUFBUixDQUFuQjtBQUNBLGNBQUlFLFVBQVUsR0FBR2pILEtBQUssQ0FBQ0ksY0FBTixDQUFxQjBGLEtBQUssQ0FBQ3BGLElBQTNCLENBQWpCO0FBQ0F1RyxvQkFBVSxDQUFDM0csS0FBWCxJQUFvQndFLElBQXBCOztBQUNBZ0IsZUFBSyxDQUFDcEcsS0FBTixDQUFZZ0IsSUFBWixDQUFpQlYsS0FBSyxDQUFDK0IsVUFBTixDQUFpQmtGLFVBQWpCLENBQWpCO0FBQ0gsU0FORDs7QUFPQUosZ0JBQVEsQ0FBQ0ssZ0JBQVQsQ0FBMEIsT0FBMUIsRUFBbUMsWUFBWTtBQUFFLGlCQUFPSixPQUFPLEVBQWQ7QUFBbUIsU0FBcEU7QUFDSCxPQVREOztBQVVBLFdBQUssSUFBSUssRUFBRSxHQUFHLENBQVQsRUFBWUMsU0FBUyxHQUFHVCxPQUE3QixFQUFzQ1EsRUFBRSxHQUFHQyxTQUFTLENBQUMvSCxNQUFyRCxFQUE2RDhILEVBQUUsRUFBL0QsRUFBbUU7QUFDL0QsWUFBSU4sUUFBUSxHQUFHTyxTQUFTLENBQUNELEVBQUQsQ0FBeEI7O0FBQ0FQLGVBQU8sQ0FBQ0MsUUFBRCxDQUFQO0FBQ0g7QUFDSjs7QUFDRCxRQUFJUSxLQUFLLEdBQUdoRixVQUFVLENBQUNDLE1BQVgsQ0FBa0IsS0FBS3FELE9BQXZCLEVBQWdDLGdCQUFoQyxDQUFaOztBQUNBLFFBQUkyQixPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFVQyxJQUFWLEVBQWdCO0FBQzFCQSxVQUFJLENBQUNMLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLFlBQVk7QUFDdkMsWUFBSXJILEtBQUssR0FBR3dDLFVBQVUsQ0FBQ1UsSUFBWCxDQUFnQndFLElBQWhCLEVBQXNCLFdBQXRCLENBQVo7O0FBQ0EsWUFBSSxDQUFDMUgsS0FBTCxFQUFZO0FBQ1I7QUFDSDs7QUFDRGlHLGFBQUssQ0FBQ3BHLEtBQU4sQ0FBWTRDLE1BQVosQ0FBbUIsSUFBSW5DLElBQUosQ0FBU04sS0FBVCxDQUFuQjtBQUNILE9BTkQ7QUFPSCxLQVJEOztBQVNBLFNBQUssSUFBSW9DLEVBQUUsR0FBRyxDQUFULEVBQVl1RixPQUFPLEdBQUdILEtBQTNCLEVBQWtDcEYsRUFBRSxHQUFHdUYsT0FBTyxDQUFDbkksTUFBL0MsRUFBdUQ0QyxFQUFFLEVBQXpELEVBQTZEO0FBQ3pELFVBQUlzRixJQUFJLEdBQUdDLE9BQU8sQ0FBQ3ZGLEVBQUQsQ0FBbEI7O0FBQ0FxRixhQUFPLENBQUNDLElBQUQsQ0FBUDtBQUNIO0FBQ0osR0F4REQ7O0FBeURBN0IsbUJBQWlCLENBQUNuRyxTQUFsQixDQUE0QmtJLFFBQTVCLEdBQXVDLFVBQVVDLElBQVYsRUFBZ0I7QUFDbkQsU0FBS25CLFNBQUwsR0FBaUJtQixJQUFqQjtBQUNILEdBRkQ7O0FBR0EsU0FBT2hDLGlCQUFQO0FBQ0gsQ0E5RXdCLEVBQXpCOztBQStFQSxJQUFJSyxNQUFNLEdBQUcsSUFBSUwsaUJBQUosQ0FBc0IsU0FBdEIsRUFBaUM7QUFDMUNpQyxXQUFTLEVBQUUsQ0FEK0I7QUFFMUNDLE1BQUksRUFBRTtBQUZvQyxDQUFqQyxDQUFiO0FBSUE3QixNQUFNLENBQUNyRyxLQUFQLENBQWFtSSxXQUFiLENBQXlCLFVBQVVDLENBQVYsRUFBYTtBQUNsQyxNQUFJbEgsR0FBRyxHQUFHa0gsQ0FBQyxDQUFDakgsTUFBRixFQUFWOztBQUNBLFNBQU9ELEdBQUcsS0FBSyxDQUFSLElBQWFBLEdBQUcsS0FBSyxDQUE1QjtBQUNILENBSEQ7QUFJQW1GLE1BQU0sQ0FBQ3JHLEtBQVAsQ0FBYWdCLElBQWIsQ0FBa0IsSUFBSVAsSUFBSixDQUFTLElBQVQsRUFBZSxFQUFmLEVBQW1CLENBQW5CLENBQWxCO0FBQ0EsSUFBSTRILFVBQVUsR0FBRyxDQUFDLElBQUk1SCxJQUFKLENBQVMsWUFBVCxDQUFELEVBQXlCLElBQUlBLElBQUosQ0FBUyxZQUFULENBQXpCLENBQWpCO0FBQ0E0RixNQUFNLENBQUNyRyxLQUFQLENBQWE4RixLQUFiLENBQW1CdUMsVUFBbkI7QUFDQWhDLE1BQU0sQ0FBQzBCLFFBQVAsQ0FBZ0IsVUFBVTVILEtBQVYsRUFBaUI7QUFDN0JtSSxTQUFPLENBQUNDLEdBQVIsQ0FBWSxVQUFaLEVBQXdCcEksS0FBeEI7QUFDQTRDLFVBQVEsQ0FBQ3lGLGNBQVQsQ0FBd0IsT0FBeEIsRUFBaUNDLFNBQWpDLEdBQTZDdEksS0FBSyxDQUFDK0QsSUFBTixDQUFXLEdBQVgsQ0FBN0M7QUFDSCxDQUhEO0FBSUF3RSxNQUFNLENBQUMsV0FBRCxDQUFOLEdBQXNCckMsTUFBdEIiLCJmaWxlIjoiLi9leGFtcGxlL2luZGV4LnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLi9cIik7XG52YXIgVGltZXggPSB7XG4gICAgaXNEYXRlOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCBpbnN0YW5jZW9mIERhdGU7IH0sXG4gICAgZGF0ZUNvbXBvbmVudHM6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgbW9udGggPSBpbnB1dC5nZXRNb250aCgpO1xuICAgICAgICB2YXIgeWVhciA9IGlucHV0LmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIHZhciBkYXRlID0gaW5wdXQuZ2V0RGF0ZSgpO1xuICAgICAgICB2YXIgZGF5ID0gaW5wdXQuZ2V0RGF5KCk7XG4gICAgICAgIHZhciBob3VycyA9IGlucHV0LmdldEhvdXJzKCk7XG4gICAgICAgIHZhciBtaW51dGVzID0gaW5wdXQuZ2V0TWludXRlcygpO1xuICAgICAgICB2YXIgc2Vjb25kcyA9IGlucHV0LmdldFNlY29uZHMoKTtcbiAgICAgICAgdmFyIG1zID0gaW5wdXQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgICAgIHZhciBkYXRlU3RyaW5nID0gaW5wdXQudG9EYXRlU3RyaW5nKCk7XG4gICAgICAgIHZhciBpc29TdHJpbmcgPSBpbnB1dC50b0lTT1N0cmluZygpO1xuICAgICAgICB2YXIgdGltZSA9IGlucHV0LmdldFRpbWUoKTtcbiAgICAgICAgdmFyIHRpbWV6b25lT2Zmc2V0ID0gaW5wdXQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICAgICAgbW9udGg6IG1vbnRoLFxuICAgICAgICAgICAgZGF5OiBkYXksXG4gICAgICAgICAgICBob3VyczogaG91cnMsXG4gICAgICAgICAgICBtaW51dGVzOiBtaW51dGVzLFxuICAgICAgICAgICAgc2Vjb25kczogc2Vjb25kcyxcbiAgICAgICAgICAgIG1zOiBtcyxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbXMsXG4gICAgICAgICAgICBkYXRlU3RyaW5nOiBkYXRlU3RyaW5nLFxuICAgICAgICAgICAgaXNvU3RyaW5nOiBpc29TdHJpbmcsXG4gICAgICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICAgICAgdGltZXpvbmVPZmZzZXQ6IHRpbWV6b25lT2Zmc2V0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVEYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgeWVhciA9IG9wdGlvbnMueWVhciwgbW9udGggPSBvcHRpb25zLm1vbnRoLCBkYXRlID0gb3B0aW9ucy5kYXRlLCBfYSA9IG9wdGlvbnMubWludXRlcywgbWludXRlcyA9IF9hID09PSB2b2lkIDAgPyAwIDogX2EsIF9iID0gb3B0aW9ucy5ob3VycywgaG91cnMgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLCBfYyA9IG9wdGlvbnMuc2Vjb25kcywgc2Vjb25kcyA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsIF9kID0gb3B0aW9ucy5taWxsaXNlY29uZHMsIG1pbGxpc2Vjb25kcyA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcyk7XG4gICAgfVxufTtcbnZhciBET01IZWxwZXJzID0ge1xuICAgIHNlbGVjdDogZnVuY3Rpb24gKHNlbGVjdG9yLCBzZWxlY3RvciQyKSB7XG4gICAgICAgIGlmICghc2VsZWN0b3IkMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0QWxsID0gZnVuY3Rpb24gKHdobywgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBBcnJheU5vZGVzID0gd2hvLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKEFycmF5Tm9kZXMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5Tm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5Tm9kZXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXlOb2RlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdEFsbChzZWxlY3Rvciwgc2VsZWN0b3IkMik7XG4gICAgfSxcbiAgICBhdHRyOiBmdW5jdGlvbiAoZWwsIGF0dHIpIHsgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShhdHRyKTsgfSxcbiAgICBjbGFzczogZnVuY3Rpb24gKGluZGV4LCBvcHRpb25zKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzbmFtZShvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgaXNBY3RpdmUgPSBvcHRpb25zLmlzQWN0aXZlLCBpc1N0YXJ0ID0gb3B0aW9ucy5pc1N0YXJ0LCBpc0VuZCA9IG9wdGlvbnMuaXNFbmQsIGlzRGlzYWJsZWQgPSBvcHRpb25zLmlzRGlzYWJsZWQsIGluUmFuZ2UgPSBvcHRpb25zLmluUmFuZ2U7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IFwiYWN0aXZlXCI7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gXCJhY3RpdmUgc3RhcnQtZGF0ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0VuZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBcImFjdGl2ZSBlbmQtZGF0ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaW4tcmFuZ2VcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkICYmICFpc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IFwiZGlzYWJsZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVzID0gW1wiY2FsZW5kYXItY2VsbFwiXTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKFwiaXMtd2Vla2RheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gNikge1xuICAgICAgICAgICAgbmFtZXMucHVzaChcImlzLXdlZWtlbmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZXMucHVzaChjbGFzc25hbWUob3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gbmFtZXMuam9pbihcIiBcIikudHJpbSgpO1xuICAgIH1cbn07XG5mdW5jdGlvbiByZW5kZXJUZW1wbGF0ZShkYXRhKSB7XG4gICAgdmFyIGlzRGVmID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsOyB9O1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRhZyh0YWcsIHByb3BzKSB7XG4gICAgICAgIGlmICghdGFnKSB7XG4gICAgICAgICAgICB0YWcgPSBcImRpdlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvcHNba2V5XTtcbiAgICAgICAgICAgIGlmIChpc0RlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSBcImNoaWxkcmVuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJjbGFzc05hbWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gXCJjbGFzc1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChrZXkgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdmFsdWUuZmlsdGVyKGlzRGVmKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcgKyBcIiBcIiArIGF0dHJpYnV0ZXMuam9pbihcIlwiKSArIFwiPlwiICsgY2hpbGRyZW4gKyBcIjwvXCIgKyB0YWcgKyBcIj5cIjtcbiAgICB9XG4gICAgdmFyIGFjdGlvbk5vZGUgPSBmdW5jdGlvbiAodHlwZSwgc3RlcCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gW1wiY2FsZW5kYXItYWN0aW9uXCIsIHR5cGVdO1xuICAgICAgICByZXR1cm4gY3JlYXRlVGFnKFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLmpvaW4oXCIgXCIpLFxuICAgICAgICAgICAgXCJkYXRhLXN0ZXBcIjogc3RlcFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRhdGVOb2RlcyhkYXRhKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogRE9NSGVscGVycy5jbGFzcyhkYXRhLmRheSwgZGF0YS5zdGF0dXMpLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgIH07XG4gICAgICAgIHByb3BzLmNoaWxkcmVuLnB1c2goY3JlYXRlVGFnKFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJkYXRlXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogZGF0YS5sYWJlbFxuICAgICAgICB9KSk7XG4gICAgICAgIHByb3BzW1wiZGF0YS1kYXRlXCJdID0gZGF0YS52YWx1ZTtcbiAgICAgICAgcHJvcHNbXCJkYXRhLWRpc2FibGVkXCJdID0gZGF0YS5kaXNhYmxlZDtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRhZyhcImRpdlwiLCBwcm9wcyk7XG4gICAgfVxuICAgIHZhciBjYWxlbmRhcnMgPSBkYXRhLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgY2FsZW5kYXJWaWV3RGF0YSA9IFtcbiAgICAgICAgICAgIGNyZWF0ZVRhZyhcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNhbGVuZGFyLWhlYWRcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogaXRlbS5oZWFkaW5nXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNyZWF0ZVRhZyhcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNhbGVuZGFyLWRheVwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXCLml6VcIiwgXCLkuIBcIiwgXCLkuoxcIiwgXCLkuIlcIiwgXCLlm5tcIiwgXCLkupRcIiwgXCLlha1cIl0ubWFwKGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRhZyhcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiY2FsZW5kYXItY2VsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGRheVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjcmVhdGVUYWcoXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjYWxlbmRhci1ib2R5XCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGl0ZW0uZGF0ZXMubWFwKGRhdGVOb2RlcylcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBjcmVhdGVUYWcoXCJkaXZcIiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNhbGVuZGFyLWl0ZW1cIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjYWxlbmRhclZpZXdEYXRhXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBbYWN0aW9uTm9kZShcInByZXZcIiwgLTEpLCBhY3Rpb25Ob2RlKFwibmV4dFwiLCAxKV0uY29uY2F0KGNhbGVuZGFycykuam9pbihcIlwiKTtcbn1cbnZhciBUeXBlUGlja2VyRXhhbXBsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHlwZVBpY2tlckV4YW1wbGUoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmFwcGx5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbml0KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBUeXBlUGlja2VyRXhhbXBsZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gRE9NSGVscGVycy5zZWxlY3QoZWxlbWVudCk7XG4gICAgICAgIHZhciBwaWNrZXIgPSBuZXcgX18xLmRlZmF1bHQoY29uZmlnKTtcbiAgICAgICAgcGlja2VyLmxpc3Rlbih0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5hcHBseSA9IF9fYXNzaWduKHt9LCBwaWNrZXIuYXBwbHksIHsgZGF0ZTogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXRlID0gZGF0ZTtcbiAgICAgICAgICAgICAgICBwaWNrZXIuYXBwbHkuZGF0ZShkYXRlKTtcbiAgICAgICAgICAgIH0gfSk7XG4gICAgICAgIHRoaXMuYXBwbHkuZGF0ZShuZXcgRGF0ZSgpKTtcbiAgICB9O1xuICAgIFR5cGVQaWNrZXJFeGFtcGxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGF0YSA9IG9wdGlvbnMucGF5bG9hZDtcbiAgICAgICAgaWYgKG9wdGlvbnMudHlwZSAhPT0gb3B0aW9ucy50eXBlcy51cGRhdGUpIHtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS50b0xvY2FsZURhdGVTdHJpbmcoKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vblNlbGVjdChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gcmVuZGVyVGVtcGxhdGUoZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGVhZGluZzogaXRlbS55ZWFyICsgXCJcXHU1RTc0IFwiICsgKGl0ZW0ubW9udGggKyAxKSArIFwiXFx1NjcwOFwiLFxuICAgICAgICAgICAgICAgIGRhdGVzOiBpdGVtLmRhdGVzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnZhbHVlID0gaXRlbS5kYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmxhYmVsID0gaXRlbS5kYXRlLmdldERhdGUoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRheSA9IGl0ZW0uZGF0ZS5nZXREYXkoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaXRlbS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1c1trZXldID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMuaXNEaXNhYmxlZCA9IGl0ZW0uZGlzYWJsZWQgfHwgaXRlbS5pbnZhbGlkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IERPTUhlbHBlcnMuc2VsZWN0KHRoaXMuZWxlbWVudCwgXCIuY2FsZW5kYXItYWN0aW9uXCIpO1xuICAgICAgICBpZiAoYWN0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoYWN0aW9uZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGVwID0gRE9NSGVscGVycy5hdHRyKGFjdGlvbmVyLCBcImRhdGEtc3RlcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBwYXJzZUludChfc3RlcCwgMTApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IFRpbWV4LmRhdGVDb21wb25lbnRzKF90aGlzLmRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLm1vbnRoICs9IHN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFwcGx5LmRhdGUoVGltZXguY3JlYXRlRGF0ZShjb21wb25lbnRzKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhY3Rpb25lci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RlcHBlcigpOyB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGFjdGlvbnNfMSA9IGFjdGlvbnM7IF9pIDwgYWN0aW9uc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25lciA9IGFjdGlvbnNfMVtfaV07XG4gICAgICAgICAgICAgICAgX2xvb3BfMShhY3Rpb25lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNlbGxzID0gRE9NSGVscGVycy5zZWxlY3QodGhpcy5lbGVtZW50LCBcIi5jYWxlbmRhci1jZWxsXCIpO1xuICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gRE9NSGVscGVycy5hdHRyKG5vZGUsIFwiZGF0YS1kYXRlXCIpO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5hcHBseS5zZWxlY3QobmV3IERhdGUodmFsdWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIGNlbGxzXzEgPSBjZWxsczsgX2EgPCBjZWxsc18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBjZWxsc18xW19hXTtcbiAgICAgICAgICAgIF9sb29wXzIobm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFR5cGVQaWNrZXJFeGFtcGxlLnByb3RvdHlwZS5vblNlbGVjdCA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHRoaXMuX29uU2VsZWN0ID0gbmV4dDtcbiAgICB9O1xuICAgIHJldHVybiBUeXBlUGlja2VyRXhhbXBsZTtcbn0oKSk7XG52YXIgcGlja2VyID0gbmV3IFR5cGVQaWNrZXJFeGFtcGxlKFwiI3BpY2tlclwiLCB7XG4gICAgc2VsZWN0aW9uOiAyLFxuICAgIHNpemU6IDlcbn0pO1xucGlja2VyLmFwcGx5LmRpc2FibGVEYXRlKGZ1bmN0aW9uIChfKSB7XG4gICAgdmFyIGRheSA9IF8uZ2V0RGF5KCk7XG4gICAgcmV0dXJuIGRheSA9PT0gNCB8fCBkYXkgPT09IDI7XG59KTtcbnBpY2tlci5hcHBseS5kYXRlKG5ldyBEYXRlKDIwMTksIDEwLCAxKSk7XG52YXIgZGF0ZXNUb1NldCA9IFtuZXcgRGF0ZShcIjIwMTkvMDcvMzFcIiksIG5ldyBEYXRlKFwiMjAxOS8wOC8wMlwiKV07XG5waWNrZXIuYXBwbHkuZGF0ZXMoZGF0ZXNUb1NldCk7XG5waWNrZXIub25TZWxlY3QoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgY29uc29sZS5sb2coXCJvbnNlbGVjdFwiLCB2YWx1ZSk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ2YWx1ZVwiKS5pbm5lclRleHQgPSB2YWx1ZS5qb2luKFwiLFwiKTtcbn0pO1xud2luZG93W1wicGlja2VyQXBwXCJdID0gcGlja2VyO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./example/index.ts\n");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./dist/typepicker.development.js */ \"./dist/typepicker.development.js\");\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbmRleC5qcz8wMjc5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQztBQUNELG1CQUFtQixtQkFBTyxDQUFDLDBFQUFrQztBQUM3RCIsImZpbGUiOiIuL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9kaXN0L3R5cGVwaWNrZXIucHJvZHVjdGlvbi5qc1wiKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vZGlzdC90eXBlcGlja2VyLmRldmVsb3BtZW50LmpzXCIpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./index.js\n");

/***/ })

/******/ });